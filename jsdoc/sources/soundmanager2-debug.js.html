<!--  -->
<HTML>
<HEAD>
<TITLE></TITLE>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../inc/stylesheet.css">
</HEAD>

<BODY style="margin:5px;">
<div style="float:right;">
<span class="button" onclick="if(window.history.length > 1) window.history.go(-1);">Back</span>
</div>
<div style="margin-left:5px;">library\sm2\soundmanager2-debug.js</div>
<pre class="source">
<span class="multiComment">/** @license
 *
 * SoundManager 2: JavaScript Sound for the Web
 * ----------------------------------------------
 * http://schillmania.com/projects/soundmanager2/
 *
 * Copyright (c) 2007, Scott Schiller. All rights reserved.
 * Code provided under the BSD License:
 * http://schillmania.com/projects/soundmanager2/license.txt
 *
 * V2.97a.20120318
 */</span>

<span class="multiComment">/*global window, SM2_DEFER, sm2Debugger, console, document, navigator, setTimeout, setInterval, clearInterval, Audio */</span>
<span class="multiComment">/*jslint regexp: true, sloppy: true, white: true, nomen: true, plusplus: true */</span>

<span class="multiComment">/**
 * About this file
 * ---------------
 * This is the fully-commented source version of the SoundManager 2 API,
 * recommended for use during development and testing.
 *
 * See soundmanager2-nodebug-jsmin.js for an optimized build (~10KB with gzip.)
 * http://schillmania.com/projects/soundmanager2/doc/getstarted/#basic-inclusion
 * Alternately, serve this file with gzip for 75% compression savings (~30KB over HTTP.)
 *
 * You may notice &lt;d&gt; and &lt;/d&gt; comments in this source; these are delimiters for
 * debug blocks which are removed in the -nodebug builds, further optimizing code size.
 *
 * Also, as you may note: Whoa, reliable cross-platform/device audio support is hard! ;)
 */</span>

(<b>function </b>(window) {

<b>var </b>soundManager = <b>null</b>;

<span class="multiComment">/**
 * The SoundManager constructor.
 *
 * @constructor
 * @param {string} smURL Optional: Path to SWF files
 * @param {string} smID Optional: The ID to use for the SWF container element
 * @this {SoundManager}
 * @return {SoundManager} The new SoundManager instance
 */</span>

function SoundManager(smURL, smID) {

<span class="singleComment">  // Top-level configuration options</span>

  <b>this</b>.flashVersion = 8;             // flash build to use (8 or 9.) Some API features require 9.
  <b>this</b>.debugMode = <b>true</b>;             // enable debugging output (console.log() with HTML fallback)
  <b>this</b>.debugFlash = <b>false</b>;           // enable debugging output inside SWF, troubleshoot Flash/browser issues
  <b>this</b>.useConsole = <b>true</b>;            // use console.log() if available (otherwise, writes to #soundmanager-debug element)
  <b>this</b>.consoleOnly = <b>true</b>;           // if console is being used, do not create/write to #soundmanager-debug
  <b>this</b>.waitForWindowLoad = <b>false</b>;    // force SM2 to wait for window.onload() before trying to call soundManager.onload()
  <b>this</b>.bgColor = '#ffffff';          // SWF background color. N/A when wmode = 'transparent'
  <b>this</b>.useHighPerformance = <b>false</b>;   // position:fixed flash movie can help increase js/flash speed, minimize lag
  <b>this</b>.flashPollingInterval = <b>null</b>;  // msec affecting whileplaying/loading callback frequency. If <b>null</b>, <b>default </b>of 50 msec is used.
  <b>this</b>.html5PollingInterval = <b>null</b>;  // msec affecting whileplaying() for HTML5 audio, excluding mobile devices. If <b>null</b>, native HTML5 update events are used.
  <b>this</b>.flashLoadTimeout = 1000;      // msec to wait for flash movie to load before failing (0 = infinity)
  <b>this</b>.wmode = <b>null</b>;                 // flash rendering mode - <b>null</b>, 'transparent', or 'opaque' (last two allow z-index to work)
  <b>this</b>.allowScriptAccess = 'always'; // for scripting the SWF (object/embed property), 'always' or 'sameDomain'
  <b>this</b>.useFlashBlock = <b>false</b>;        // *requires flashblock.css, see demos* - allow recovery from flash blockers. Wait indefinitely and apply timeout CSS to SWF, if applicable.
  <b>this</b>.useHTML5Audio = <b>true</b>;         // use HTML5 Audio() where API is supported (most Safari, Chrome versions), Firefox (no MP3/MP4.) Ideally, transparent vs. Flash API where possible.
  <b>this</b>.html5Test = /^(probably|maybe)$/i; // HTML5 Audio() format support test. Use /^probably$/i; if you want to be more conservative.
  <b>this</b>.preferFlash = <b>true</b>;           // overrides useHTML5audio. if <b>true</b> and flash support present, will try to use flash for MP3/MP4 as needed since HTML5 audio support is still quirky<b> in </b>browsers.
  <b>this</b>.noSWFCache = <b>false</b>;           // if <b>true</b>, appends ?ts={date} to <b>break</b> aggressive SWF caching.

  <b>this</b>.audioFormats = {

<span class="multiComment">    /**
     * determines HTML5 support + flash requirements.
     * if no support (via flash and/or HTML5) for a "required" format, SM2 will fail to start.
     * flash fallback is used for MP3 or MP4 if HTML5 can't play it (or if preferFlash = true)
     * multiple MIME types may be tested while trying to get a positive canPlayType() response.
     */</span>

    'mp3': {
      'type': ['audio/mpeg; codecs="mp3"', 'audio/mpeg', 'audio/mp3', 'audio/MPA', 'audio/mpa-robust'],
      'required': <b>true</b>
    },

    'mp4': {
      'related': ['aac','m4a'], // additional formats under the MP4 container
      'type': ['audio/mp4; codecs="mp4a.40.2"', 'audio/aac', 'audio/x-m4a', 'audio/MP4A-LATM', 'audio/mpeg4-generic'],
      'required': <b>false</b>
    },

    'ogg': {
      'type': ['audio/ogg; codecs=vorbis'],
      'required': <b>false</b>
    },

    'wav': {
      'type': ['audio/wav; codecs="1"', 'audio/wav', 'audio/wave', 'audio/x-wav'],
      'required': <b>false</b>
    }

  };

  <b>this</b>.defaultOptions = {

<span class="multiComment">    /**
     * the default configuration for sound objects made with createSound() and related methods
     * eg., volume, auto-load behaviour and so forth
     */</span>

    'autoLoad': <b>false</b>,        // enable automatic loading (otherwise .load() will be called on demand with .play(), the latter being nicer on bandwidth - if you want to .load yourself, you also can)
    'autoPlay': <b>false</b>,        // enable playing of file as soon as possible (much faster if "stream" is <b>true</b>)
    'from': <b>null</b>,             // position to start playback within a sound (msec), <b>default </b>= beginning
    'loops': 1,               // how many times to repeat the sound (position will wrap around to 0, setPosition() will <b>break</b> out of loop when &gt;0)
    'onid3': <b>null</b>,            // callback function for "ID3 data is added/available"
    'onload': <b>null</b>,           // callback function for "load finished"
    'whileloading': <b>null</b>,     // callback function for "download progress update" (X of Y bytes received)
    'onplay': <b>null</b>,           // callback for "play" start
    'onpause': <b>null</b>,          // callback for "pause"
    'onresume': <b>null</b>,         // callback for "resume" (pause toggle)
    'whileplaying': <b>null</b>,     // callback during play (position update)
    'onposition': <b>null</b>,       // object containing times and function callbacks for positions of interest
    'onstop': <b>null</b>,           // callback for "user stop"
    'onfailure': <b>null</b>,        // callback function for when playing fails
    'onfinish': <b>null</b>,         // callback function for "sound finished playing"
    'multiShot': <b>true</b>,        // let sounds "restart" or layer on top of each other when played multiple times, rather than one-shot/one at a time
    'multiShotEvents': <b>false</b>, // fire multiple sound events (currently onfinish() only) when multiShot is enabled
    'position': <b>null</b>,         // offset (milliseconds) to seek to within loaded sound data.
    'pan': 0,                 // "pan" settings, left-to-right, -100 to 100
    'stream': <b>true</b>,           // allows playing before entire file has loaded (recommended)
    'to': <b>null</b>,               // position to end playback within a sound (msec), <b>default </b>= end
    'type': <b>null</b>,             // MIME-like hint for file pattern / canPlay() tests, eg. audio/mp3
    'usePolicyFile': <b>false</b>,   // enable crossdomain.xml request for audio on remote domains (for ID3/waveform access)
    'volume': 100             // self-explanatory. 0-100, the latter being the max.

  };

  <b>this</b>.flash9Options = {

<span class="multiComment">    /**
     * flash 9-only options,
     * merged into defaultOptions if flash 9 is being used
     */</span>

    'isMovieStar': <b>null</b>,      // "MovieStar" MPEG4 audio mode. Null (default) = auto detect MP4, AAC etc. based on URL. <b>true</b> = force on, ignore URL
    'usePeakData': <b>false</b>,     // enable left/right channel peak (level) data
    'useWaveformData': <b>false</b>, // enable sound spectrum (raw waveform data) - NOTE: May increase CPU load.
    'useEQData': <b>false</b>,       // enable sound EQ (frequency spectrum data) - NOTE: May increase CPU load.
    'onbufferchange': <b>null</b>,   // callback for "isBuffering" property change
    'ondataerror': <b>null</b>       // callback for waveform/eq data access error (flash playing audio<b> in </b>other tabs/domains)

  };

  <b>this</b>.movieStarOptions = {

<span class="multiComment">    /**
     * flash 9.0r115+ MPEG4 audio options,
     * merged into defaultOptions if flash 9+movieStar mode is enabled
     */</span>

    'bufferTime': 3,          // seconds of data to buffer before playback begins (<b>null</b> = flash <b>default </b>of 0.1 seconds - if AAC playback is gappy, try increasing.)
    'serverURL': <b>null</b>,        // rtmp: FMS or FMIS server to connect to, required when requesting media via RTMP or one of its variants
    'onconnect': <b>null</b>,        // rtmp: callback for connection to flash media server
    'duration': <b>null</b>          // rtmp: song duration (msec)

  };

<span class="singleComment">  // HTML attributes (id + class names) for the SWF container</span>

  <b>this</b>.movieID = 'sm2-container';
  <b>this</b>.id = (smID || 'sm2movie');

  <b>this</b>.debugID = 'soundmanager-debug';
  <b>this</b>.debugURLParam = /([#?&])debug=1/i;

<span class="singleComment">  // dynamic attributes</span>

  <b>this</b>.versionNumber = 'V2.97a.20120318';
  <b>this</b>.version = <b>null</b>;
  <b>this</b>.movieURL = <b>null</b>;
  <b>this</b>.url = (smURL || <b>null</b>);
  <b>this</b>.altURL = <b>null</b>;
  <b>this</b>.swfLoaded = <b>false</b>;
  <b>this</b>.enabled = <b>false</b>;
  <b>this</b>.oMC = <b>null</b>;
  <b>this</b>.sounds = {};
  <b>this</b>.soundIDs = [];
  <b>this</b>.muted = <b>false</b>;
  <b>this</b>.didFlashBlock = <b>false</b>;
  <b>this</b>.filePattern = <b>null</b>;

  <b>this</b>.filePatterns = {

    'flash8': /\.mp3(\?.*)?$/i,
    'flash9': /\.mp3(\?.*)?$/i

  };

<span class="singleComment">  // support indicators, set at init</span>

  <b>this</b>.features = {

    'buffering': <b>false</b>,
    'peakData': <b>false</b>,
    'waveformData': <b>false</b>,
    'eqData': <b>false</b>,
    'movieStar': <b>false</b>

  };

<span class="singleComment">  // flash sandbox info, used primarily in troubleshooting</span>

  <b>this</b>.sandbox = {

<span class="singleComment">    // &lt;d&gt;</span>
    'type': <b>null</b>,
    'types': {
      'remote': 'remote (domain-based) rules',
      'localWithFile': 'local with file access (no internet access)',
      'localWithNetwork': 'local with network (internet access only, no local access)',
      'localTrusted': 'local, trusted (local+internet access)'
    },
    'description': <b>null</b>,
    'noRemote': <b>null</b>,
    'noLocal': <b>null</b>
<span class="singleComment">    // &lt;/d&gt;</span>

  };

<span class="multiComment">  /**
   * basic HTML5 Audio() support test
   * try...catch because of IE 9 "not implemented" nonsense
   * https://github.com/Modernizr/Modernizr/issues/224
   */</span>

  <b>this</b>.hasHTML5 = (<b>function </b>() {
    <b>try </b>{
      <b>return</b> (<b>typeof </b>Audio !== 'undefined' && <b>typeof </b><b>new </b>Audio().canPlayType !== 'undefined');
    } <b>catch </b>(e) {
      <b>return</b> <b>false</b>;
    }
  }());

<span class="multiComment">  /**
   * format support (html5/flash)
   * stores canPlayType() results based on audioFormats.
   * eg. { mp3: boolean, mp4: boolean }
   * treat as read-only.
   */</span>

  <b>this</b>.html5 = {
    'usingFlash': <b>null</b> // set if/when flash fallback is needed
  };

  <b>this</b>.flash = {}; // file type support hash

  <b>this</b>.html5Only = <b>false</b>;   // determined at init time
  <b>this</b>.ignoreFlash = <b>false</b>; // used for special cases (eg. iPad/iPhone/palm OS?)

<span class="multiComment">  /**
   * a few private internals (OK, a lot. :D)
   */</span>

  <b>var </b>SMSound,
  _s = <b>this</b>, _flash = <b>null</b>, _sm = 'soundManager', _smc = _sm+'::', _h5 = 'HTML5::', _id, _ua = navigator.userAgent, _win = window, _wl = _win.location.href.toString(), _doc = document, _doNothing, _init, _fV, _on_queue = [], _debugOpen = <b>true</b>, _debugTS, _didAppend = <b>false</b>, _appendSuccess = <b>false</b>, _didInit = <b>false</b>, _disabled = <b>false</b>, _windowLoaded = <b>false</b>, _wDS, _wdCount = 0, _initComplete, _mixin, _addOnEvent, _processOnEvents, _initUserOnload, _delayWaitForEI, _waitForEI, _setVersionInfo, _handleFocus, _strings, _initMovie, _domContentLoaded, _winOnLoad, _didDCLoaded, _getDocument, _createMovie, _catchError, _setPolling, _initDebug, _debugLevels = ['log', 'info', 'warn', 'error'], _defaultFlashVersion = 8, _disableObject, _failSafely, _normalizeMovieURL, _oRemoved = <b>null</b>, _oRemovedHTML = <b>null</b>, _str, _flashBlockHandler, _getSWFCSS, _swfCSS, _toggleDebug, _loopFix, _policyFix, _complain, _idCheck, _waitingForEI = <b>false</b>, _initPending = <b>false</b>, _startTimer, _stopTimer, _timerExecute, _h5TimerCount = 0, _h5IntervalTimer = <b>null</b>, _parseURL,
  _needsFlash = <b>null</b>, _featureCheck, _html5OK, _html5CanPlay, _html5Ext, _html5Unload, _domContentLoadedIE, _testHTML5, _event, _slice = Array.prototype.slice, _useGlobalHTML5Audio = <b>false</b>, _hasFlash, _detectFlash, _badSafariFix, _html5_events, _showSupport,
  _is_iDevice = _ua.match(/(ipad|iphone|ipod)/i), _is_firefox = _ua.match(/firefox/i), _is_android = _ua.match(/droid/i), _isIE = _ua.match(/msie/i), _isWebkit = _ua.match(/webkit/i), _isSafari = (_ua.match(/safari/i) && !_ua.match(/chrome/i)), _isOpera = (_ua.match(/opera/i)), 
  _likesHTML5 = (_ua.match(/(mobile|pre\/|xoom)/i) || _is_iDevice),
  _isBadSafari = (!_wl.match(/usehtml5audio/i) && !_wl.match(/sm2\-ignorebadua/i) && _isSafari && !_ua.match(/silk/i) && _ua.match(/OS X 10_6_([3-7])/i)), // Safari 4 and 5 (excluding Kindle Fire, "Silk") occasionally fail to load/play HTML5 audio on Snow Leopard 10.6.3 through 10.6.7 due to bug(s)<b> in </b>QuickTime X and/or other underlying frameworks. :/ Confirmed bug. https://bugs.webkit.org/show_bug.cgi?id=32159
  _hasConsole = (<b>typeof </b>console !== 'undefined' && <b>typeof </b>console.log !== 'undefined'), _isFocused = (<b>typeof </b>_doc.hasFocus !== 'undefined'?_doc.hasFocus():<b>null</b>), _tryInitOnFocus = (_isSafari && <b>typeof </b>_doc.hasFocus === 'undefined'), _okToDisable = !_tryInitOnFocus, _flashMIME = /(mp3|mp4|mpa)/i,
  _emptyURL = 'about:blank', // safe URL to unload, or load nothing from (flash 8 + most HTML5 UAs)
  _overHTTP = (_doc.location?_doc.location.protocol.match(/http/i):<b>null</b>),
  _http = (!_overHTTP ? 'http:/'+'/' : ''),
<span class="singleComment">  // mp3, mp4, aac etc.</span>
  _netStreamMimeTypes = /^\s*audio\/(?:x-)?(?:mpeg4|aac|flv|mov|mp4||m4v|m4a|mp4v|3gp|3g2)\s*(?:$|;)/i,
<span class="singleComment">  // Flash v9.0r115+ "moviestar" formats</span>
  _netStreamTypes = ['mpeg4', 'aac', 'flv', 'mov', 'mp4', 'm4v', 'f4v', 'm4a', 'mp4v', '3gp', '3g2'],
  _netStreamPattern = <b>new </b>RegExp('\\.(' + _netStreamTypes.join('|') + ')(\\?.*)?$', 'i');

  <b>this</b>.mimePattern = /^\s*audio\/(?:x-)?(?:mp(?:eg|3))\s*(?:$|;)/i; // <b>default </b>mp3 set

<span class="singleComment">  // use altURL if not "online"</span>
  <b>this</b>.useAltURL = !_overHTTP;
  <b>this</b>._global_a = <b>null</b>;

  _swfCSS = {

    'swfBox': 'sm2-object-box',
    'swfDefault': 'movieContainer',
    'swfError': 'swf_error', // SWF loaded, but SM2 couldn't start (other error)
    'swfTimedout': 'swf_timedout',
    'swfLoaded': 'swf_loaded',
    'swfUnblocked': 'swf_unblocked', // or loaded OK
    'sm2Debug': 'sm2_debug',
    'highPerf': 'high_performance',
    'flashDebug': 'flash_debug'

  };

  <b>if </b>(_likesHTML5) {

<span class="singleComment">    // prefer HTML5 for mobile + tablet-like devices, probably more reliable vs. flash at this point.</span>
    _s.useHTML5Audio = <b>true</b>;
    _s.preferFlash = <b>false</b>;

    <b>if </b>(_is_iDevice) {
<span class="singleComment">      // by default, use global feature. iOS onfinish() -&gt; next may fail otherwise.</span>
      _s.ignoreFlash = <b>true</b>;
      _useGlobalHTML5Audio = <b>true</b>;
    }

  }

<span class="multiComment">  /**
   * Public SoundManager API
   * -----------------------
   */</span>

  <b>this</b>.ok = <b>function </b>() {

    <b>return</b> (_needsFlash?(_didInit && !_disabled):(_s.useHTML5Audio && _s.hasHTML5));

  };

  <b>this</b>.supported = <b>this</b>.ok; // legacy

  <b>this</b>.getMovie = <b>function </b>(smID) {

<span class="singleComment">    // safety net: some old browsers differ on SWF references, possibly related to ExternalInterface / flash version</span>
    <b>return</b> _id(smID) || _doc[smID] || _win[smID];

  };

<span class="multiComment">  /**
   * Creates a SMSound sound object instance.
   *
   * @param {object} oOptions Sound options (at minimum, id and url are required.)
   * @return {object} SMSound The new SMSound object.
   */</span>

  <b>this</b>.createSound = <b>function </b>(oOptions) {

    <b>var </b>_cs, _cs_string,
    <b>this</b>Options = <b>null</b>, oSound = <b>null</b>, _tO = <b>null</b>;

<span class="singleComment">    // &lt;d&gt;</span>
    _cs = _sm+'.createSound(): ';
    _cs_string = _cs + _str(!_didInit?'notReady':'notOK');
<span class="singleComment">    // &lt;/d&gt;</span>

    <b>if </b>(!_didInit || !_s.ok()) {
      _complain(_cs_string);
      <b>return</b> <b>false</b>;
    }

    <b>if </b>(arguments.length === 2) {
<span class="singleComment">      // function overloading in JS! :) ..assume simple createSound(id,url) use case</span>
      oOptions = {
        'id': arguments[0],
        'url': arguments[1]
      };
    }

<span class="singleComment">    // inherit from defaultOptions</span>
    <b>this</b>Options = _mixin(oOptions);

    <b>this</b>Options.url = _parseURL(<b>this</b>Options.url);

<span class="singleComment">    // local shortcut</span>
    _tO = <b>this</b>Options;

<span class="singleComment">    // &lt;d&gt;</span>
    <b>if </b>(_tO.id.toString().charAt(0).match(/^[0-9]$/)) {
      _s._wD(_cs + _str('badID', _tO.id), 2);
    }

    _s._wD(_cs + _tO.id + ' (' + _tO.url + ')', 1);
<span class="singleComment">    // &lt;/d&gt;</span>

    <b>if </b>(_idCheck(_tO.id, <b>true</b>)) {
      _s._wD(_cs + _tO.id + ' exists', 1);
      <b>return</b> _s.sounds[_tO.id];
    }

    function make() {

      <b>this</b>Options = _loopFix(<b>this</b>Options);
      _s.sounds[_tO.id] = <b>new </b>SMSound(_tO);
      _s.soundIDs.push(_tO.id);
      <b>return</b> _s.sounds[_tO.id];

    }

    <b>if </b>(_html5OK(_tO)) {

      oSound = make();
      _s._wD('Loading sound '+_tO.id+' via HTML5');
      oSound._setup_html5(_tO);

    } <b>else </b>{

      <b>if </b>(_fV &gt; 8) {
        <b>if </b>(_tO.isMovieStar === <b>null</b>) {
<span class="singleComment">          // attempt to detect MPEG-4 formats</span>
          _tO.isMovieStar = (_tO.serverURL || (_tO.type ? _tO.type.match(_netStreamMimeTypes) : <b>false</b>) || _tO.url.match(_netStreamPattern));
        }
<span class="singleComment">        // &lt;d&gt;</span>
        <b>if </b>(_tO.isMovieStar) {
          _s._wD(_cs + 'using MovieStar handling');
        }
<span class="singleComment">        // &lt;/d&gt;</span>
        <b>if </b>(_tO.isMovieStar) {
          <b>if </b>(_tO.usePeakData) {
            _wDS('noPeak');
            _tO.usePeakData = <b>false</b>;
          }
<span class="singleComment">          // &lt;d&gt;</span>
          <b>if </b>(_tO.loops &gt; 1) {
            _wDS('noNSLoop');
          }
<span class="singleComment">          // &lt;/d&gt;</span>
        }
      }

      _tO = _policyFix(_tO, _cs);
      oSound = make();

      <b>if </b>(_fV === 8) {
        _flash._createSound(_tO.id, _tO.loops||1, _tO.usePolicyFile);
      } <b>else </b>{
        _flash._createSound(_tO.id, _tO.url, _tO.usePeakData, _tO.useWaveformData, _tO.useEQData, _tO.isMovieStar, (_tO.isMovieStar?_tO.bufferTime:<b>false</b>), _tO.loops||1, _tO.serverURL, _tO.duration||<b>null</b>, _tO.autoPlay, <b>true</b>, _tO.autoLoad, _tO.usePolicyFile);
        <b>if </b>(!_tO.serverURL) {
<span class="singleComment">          // We are connected immediately</span>
          oSound.connected = <b>true</b>;
          <b>if </b>(_tO.onconnect) {
            _tO.onconnect.apply(oSound);
          }
        }
      }

      <b>if </b>(!_tO.serverURL && (_tO.autoLoad || _tO.autoPlay)) {
<span class="singleComment">        // call load for non-rtmp streams</span>
        oSound.load(_tO);
      }

    }

<span class="singleComment">    // rtmp will play in onconnect</span>
    <b>if </b>(!_tO.serverURL && _tO.autoPlay) {
      oSound.play();
    }

    <b>return</b> oSound;

  };

<span class="multiComment">  /**
   * Destroys a SMSound sound object instance.
   *
   * @param {string} sID The ID of the sound to destroy
   */</span>

  <b>this</b>.destroySound = <b>function </b>(sID, _bFromSound) {

<span class="singleComment">    // explicitly destroy a sound before normal page unload, etc.</span>

    <b>if </b>(!_idCheck(sID)) {
      <b>return</b> <b>false</b>;
    }

    <b>var </b>oS = _s.sounds[sID], i;

<span class="singleComment">    // Disable all callbacks while the sound is being destroyed</span>
    oS._iO = {};

    oS.stop();
    oS.unload();

    <b>for </b>(i = 0; i &lt; _s.soundIDs.length; i++) {
      <b>if </b>(_s.soundIDs[i] === sID) {
        _s.soundIDs.splice(i, 1);
        <b>break</b>;
      }
    }

    <b>if </b>(!_bFromSound) {
<span class="singleComment">      // ignore if being called from SMSound instance</span>
      oS.destruct(<b>true</b>);
    }

    oS = <b>null</b>;
    <b>delete </b>_s.sounds[sID];

    <b>return</b> <b>true</b>;

  };

<span class="multiComment">  /**
   * Calls the load() method of a SMSound object by ID.
   *
   * @param {string} sID The ID of the sound
   * @param {object} oOptions Optional: Sound options
   */</span>

  <b>this</b>.load = <b>function </b>(sID, oOptions) {

    <b>if </b>(!_idCheck(sID)) {
      <b>return</b> <b>false</b>;
    }
    <b>return</b> _s.sounds[sID].load(oOptions);

  };

<span class="multiComment">  /**
   * Calls the unload() method of a SMSound object by ID.
   *
   * @param {string} sID The ID of the sound
   */</span>

  <b>this</b>.unload = <b>function </b>(sID) {

    <b>if </b>(!_idCheck(sID)) {
      <b>return</b> <b>false</b>;
    }
    <b>return</b> _s.sounds[sID].unload();

  };

<span class="multiComment">  /**
   * Calls the onPosition() method of a SMSound object by ID.
   *
   * @param {string} sID The ID of the sound
   * @param {number} nPosition The position to watch for
   * @param {function} oMethod The relevant callback to fire
   * @param {object} oScope Optional: The scope to apply the callback to
   * @return {SMSound} The SMSound object
   */</span>

  <b>this</b>.onPosition = <b>function </b>(sID, nPosition, oMethod, oScope) {

    <b>if </b>(!_idCheck(sID)) {
      <b>return</b> <b>false</b>;
    }
    <b>return</b> _s.sounds[sID].onposition(nPosition, oMethod, oScope);

  };

<span class="singleComment">  // legacy/backwards-compability: lower-case method name</span>
  <b>this</b>.onposition = <b>this</b>.onPosition;

<span class="multiComment">  /**
   * Calls the clearOnPosition() method of a SMSound object by ID.
   *
   * @param {string} sID The ID of the sound
   * @param {number} nPosition The position to watch for
   * @param {function} oMethod Optional: The relevant callback to fire
   * @return {SMSound} The SMSound object
   */</span>

  <b>this</b>.clearOnPosition = <b>function </b>(sID, nPosition, oMethod) {

    <b>if </b>(!_idCheck(sID)) {
      <b>return</b> <b>false</b>;
    }
    <b>return</b> _s.sounds[sID].clearOnPosition(nPosition, oMethod);

  };

<span class="multiComment">  /**
   * Calls the play() method of a SMSound object by ID.
   *
   * @param {string} sID The ID of the sound
   * @param {object} oOptions Optional: Sound options
   * @return {SMSound} The SMSound object
   */</span>

  <b>this</b>.play = <b>function </b>(sID, oOptions) {

    <b>if </b>(!_didInit || !_s.ok()) {
      _complain(_sm+'.play(): ' + _str(!_didInit?'notReady':'notOK'));
      <b>return</b> <b>false</b>;
    }

    <b>if </b>(!_idCheck(sID)) {
      <b>if </b>(!(oOptions<b> instanceof </b>Object)) {
<span class="singleComment">        // overloading use case: play('mySound','/path/to/some.mp3');</span>
        oOptions = {
          url: oOptions
        };
      }
      <b>if </b>(oOptions && oOptions.url) {
<span class="singleComment">        // overloading use case, create+play: .play('someID',{url:'/path/to.mp3'});</span>
        _s._wD(_sm+'.play(): attempting to create "' + sID + '"', 1);
        oOptions.id = sID;
        <b>return</b> _s.createSound(oOptions).play();
      } <b>else </b>{
        <b>return</b> <b>false</b>;
      }
    }

    <b>return</b> _s.sounds[sID].play(oOptions);

  };

  <b>this</b>.start = <b>this</b>.play; // just for convenience

<span class="multiComment">  /**
   * Calls the setPosition() method of a SMSound object by ID.
   *
   * @param {string} sID The ID of the sound
   * @param {number} nMsecOffset Position (milliseconds)
   * @return {SMSound} The SMSound object
   */</span>

  <b>this</b>.setPosition = <b>function </b>(sID, nMsecOffset) {

    <b>if </b>(!_idCheck(sID)) {
      <b>return</b> <b>false</b>;
    }
    <b>return</b> _s.sounds[sID].setPosition(nMsecOffset);

  };

<span class="multiComment">  /**
   * Calls the stop() method of a SMSound object by ID.
   *
   * @param {string} sID The ID of the sound
   * @return {SMSound} The SMSound object
   */</span>

  <b>this</b>.stop = <b>function </b>(sID) {

    <b>if </b>(!_idCheck(sID)) {
      <b>return</b> <b>false</b>;
    }

    _s._wD(_sm+'.stop(' + sID + ')', 1);
    <b>return</b> _s.sounds[sID].stop();

  };

<span class="multiComment">  /**
   * Stops all currently-playing sounds.
   */</span>

  <b>this</b>.stopAll = <b>function </b>() {

    <b>var </b>oSound;
    _s._wD(_sm+'.stopAll()', 1);

    <b>for </b>(oSound<b> in </b>_s.sounds) {
      <b>if </b>(_s.sounds.hasOwnProperty(oSound)) {
<span class="singleComment">        // apply only to sound objects</span>
        _s.sounds[oSound].stop();
      }
    }

  };

<span class="multiComment">  /**
   * Calls the pause() method of a SMSound object by ID.
   *
   * @param {string} sID The ID of the sound
   * @return {SMSound} The SMSound object
   */</span>

  <b>this</b>.pause = <b>function </b>(sID) {

    <b>if </b>(!_idCheck(sID)) {
      <b>return</b> <b>false</b>;
    }
    <b>return</b> _s.sounds[sID].pause();

  };

<span class="multiComment">  /**
   * Pauses all currently-playing sounds.
   */</span>

  <b>this</b>.pauseAll = <b>function </b>() {

    <b>var </b>i;
    <b>for </b>(i = _s.soundIDs.length-1; i &gt;= 0; i--) {
      _s.sounds[_s.soundIDs[i]].pause();
    }

  };

<span class="multiComment">  /**
   * Calls the resume() method of a SMSound object by ID.
   *
   * @param {string} sID The ID of the sound
   * @return {SMSound} The SMSound object
   */</span>

  <b>this</b>.resume = <b>function </b>(sID) {

    <b>if </b>(!_idCheck(sID)) {
      <b>return</b> <b>false</b>;
    }
    <b>return</b> _s.sounds[sID].resume();

  };

<span class="multiComment">  /**
   * Resumes all currently-paused sounds.
   */</span>

  <b>this</b>.resumeAll = <b>function </b>() {

    <b>var </b>i;
    <b>for </b>(i = _s.soundIDs.length-1; i &gt;= 0; i--) {
      _s.sounds[_s.soundIDs[i]].resume();
    }

  };

<span class="multiComment">  /**
   * Calls the togglePause() method of a SMSound object by ID.
   *
   * @param {string} sID The ID of the sound
   * @return {SMSound} The SMSound object
   */</span>

  <b>this</b>.togglePause = <b>function </b>(sID) {

    <b>if </b>(!_idCheck(sID)) {
      <b>return</b> <b>false</b>;
    }
    <b>return</b> _s.sounds[sID].togglePause();

  };

<span class="multiComment">  /**
   * Calls the setPan() method of a SMSound object by ID.
   *
   * @param {string} sID The ID of the sound
   * @param {number} nPan The pan value (-100 to 100)
   * @return {SMSound} The SMSound object
   */</span>

  <b>this</b>.setPan = <b>function </b>(sID, nPan) {

    <b>if </b>(!_idCheck(sID)) {
      <b>return</b> <b>false</b>;
    }
    <b>return</b> _s.sounds[sID].setPan(nPan);

  };

<span class="multiComment">  /**
   * Calls the setVolume() method of a SMSound object by ID.
   *
   * @param {string} sID The ID of the sound
   * @param {number} nVol The volume value (0 to 100)
   * @return {SMSound} The SMSound object
   */</span>

  <b>this</b>.setVolume = <b>function </b>(sID, nVol) {

    <b>if </b>(!_idCheck(sID)) {
      <b>return</b> <b>false</b>;
    }
    <b>return</b> _s.sounds[sID].setVolume(nVol);

  };

<span class="multiComment">  /**
   * Calls the mute() method of either a single SMSound object by ID, or all sound objects.
   *
   * @param {string} sID Optional: The ID of the sound (if omitted, all sounds will be used.)
   */</span>

  <b>this</b>.mute = <b>function </b>(sID) {

    <b>var </b>i = 0;

    <b>if </b>(<b>typeof </b>sID !== 'string') {
      sID = <b>null</b>;
    }

    <b>if </b>(!sID) {
      _s._wD(_sm+'.mute(): Muting all sounds');
      <b>for </b>(i = _s.soundIDs.length-1; i &gt;= 0; i--) {
        _s.sounds[_s.soundIDs[i]].mute();
      }
      _s.muted = <b>true</b>;
    } <b>else </b>{
      <b>if </b>(!_idCheck(sID)) {
        <b>return</b> <b>false</b>;
      }
      _s._wD(_sm+'.mute(): Muting "' + sID + '"');
      <b>return</b> _s.sounds[sID].mute();
    }

    <b>return</b> <b>true</b>;

  };

<span class="multiComment">  /**
   * Mutes all sounds.
   */</span>

  <b>this</b>.muteAll = <b>function </b>() {

    _s.mute();

  };

<span class="multiComment">  /**
   * Calls the unmute() method of either a single SMSound object by ID, or all sound objects.
   *
   * @param {string} sID Optional: The ID of the sound (if omitted, all sounds will be used.)
   */</span>

  <b>this</b>.unmute = <b>function </b>(sID) {

    <b>var </b>i;

    <b>if </b>(<b>typeof </b>sID !== 'string') {
      sID = <b>null</b>;
    }

    <b>if </b>(!sID) {

      _s._wD(_sm+'.unmute(): Unmuting all sounds');
      <b>for </b>(i = _s.soundIDs.length-1; i &gt;= 0; i--) {
        _s.sounds[_s.soundIDs[i]].unmute();
      }
      _s.muted = <b>false</b>;

    } <b>else </b>{

      <b>if </b>(!_idCheck(sID)) {
        <b>return</b> <b>false</b>;
      }
      _s._wD(_sm+'.unmute(): Unmuting "' + sID + '"');
      <b>return</b> _s.sounds[sID].unmute();

    }

    <b>return</b> <b>true</b>;

  };

<span class="multiComment">  /**
   * Unmutes all sounds.
   */</span>

  <b>this</b>.unmuteAll = <b>function </b>() {

    _s.unmute();

  };

<span class="multiComment">  /**
   * Calls the toggleMute() method of a SMSound object by ID.
   *
   * @param {string} sID The ID of the sound
   * @return {SMSound} The SMSound object
   */</span>

  <b>this</b>.toggleMute = <b>function </b>(sID) {

    <b>if </b>(!_idCheck(sID)) {
      <b>return</b> <b>false</b>;
    }
    <b>return</b> _s.sounds[sID].toggleMute();

  };

<span class="multiComment">  /**
   * Retrieves the memory used by the flash plugin.
   *
   * @return {number} The amount of memory in use
   */</span>

  <b>this</b>.getMemoryUse = <b>function </b>() {

<span class="singleComment">    // flash-only</span>
    <b>var </b>ram = 0;

    <b>if </b>(_flash && _fV !== 8) {
      ram = parseInt(_flash._getMemoryUse(), 10);
    }

    <b>return</b> ram;

  };

<span class="multiComment">  /**
   * Undocumented: NOPs soundManager and all SMSound objects.
   */</span>

  <b>this</b>.disable = <b>function </b>(bNoDisable) {

<span class="singleComment">    // destroy all functions</span>
    <b>var </b>i;

    <b>if </b>(<b>typeof </b>bNoDisable === 'undefined') {
      bNoDisable = <b>false</b>;
    }

    <b>if </b>(_disabled) {
      <b>return</b> <b>false</b>;
    }

    _disabled = <b>true</b>;
    _wDS('shutdown', 1);

    <b>for </b>(i = _s.soundIDs.length-1; i &gt;= 0; i--) {
      _disableObject(_s.sounds[_s.soundIDs[i]]);
    }

<span class="singleComment">    // fire "complete", despite fail</span>
    _initComplete(bNoDisable);
    _event.remove(_win, 'load', _initUserOnload);

    <b>return</b> <b>true</b>;

  };

<span class="multiComment">  /**
   * Determines playability of a MIME type, eg. 'audio/mp3'.
   */</span>

  <b>this</b>.canPlayMIME = <b>function </b>(sMIME) {

    <b>var </b>result;

    <b>if </b>(_s.hasHTML5) {
      result = _html5CanPlay({type:sMIME});
    }

    <b>if </b>(!_needsFlash || result) {
<span class="singleComment">      // no flash, or OK</span>
      <b>return</b> result;
    } <b>else </b>{
<span class="singleComment">      // if flash 9, test netStream (movieStar) types as well.</span>
      <b>return</b> (sMIME && _s.ok() ? !!((_fV &gt; 8 ? sMIME.match(_netStreamMimeTypes) : <b>null</b>) || sMIME.match(_s.mimePattern)) : <b>null</b>);
    }

  };

<span class="multiComment">  /**
   * Determines playability of a URL based on audio support.
   *
   * @param {string} sURL The URL to test
   * @return {boolean} URL playability
   */</span>

  <b>this</b>.canPlayURL = <b>function </b>(sURL) {

    <b>var </b>result;

    <b>if </b>(_s.hasHTML5) {
      result = _html5CanPlay({url: sURL});
    }

    <b>if </b>(!_needsFlash || result) {
<span class="singleComment">      // no flash, or OK</span>
      <b>return</b> result;
    } <b>else </b>{
      <b>return</b> (sURL && _s.ok() ? !!(sURL.match(_s.filePattern)) : <b>null</b>);
    }

  };

<span class="multiComment">  /**
   * Determines playability of an HTML DOM &lt;a&gt; object (or similar object literal) based on audio support.
   *
   * @param {object} oLink an HTML DOM &lt;a&gt; object or object literal including href and/or type attributes
   * @return {boolean} URL playability
   */</span>

  <b>this</b>.canPlayLink = <b>function </b>(oLink) {

    <b>if </b>(<b>typeof </b>oLink.type !== 'undefined' && oLink.type) {
      <b>if </b>(_s.canPlayMIME(oLink.type)) {
        <b>return</b> <b>true</b>;
      }
    }

    <b>return</b> _s.canPlayURL(oLink.href);

  };

<span class="multiComment">  /**
   * Retrieves a SMSound object by ID.
   *
   * @param {string} sID The ID of the sound
   * @return {SMSound} The SMSound object
   */</span>

  <b>this</b>.getSoundById = <b>function </b>(sID, _suppressDebug) {

    <b>if </b>(!sID) {
      <b>throw </b><b>new </b>Error(_sm+'.getSoundById(): sID is <b>null</b>/undefined');
    }

    <b>var </b>result = _s.sounds[sID];

<span class="singleComment">    // &lt;d&gt;</span>
    <b>if </b>(!result && !_suppressDebug) {
      _s._wD('"' + sID + '" is an invalid sound ID.', 2);
    }
<span class="singleComment">    // &lt;/d&gt;</span>

    <b>return</b> result;

  };

<span class="multiComment">  /**
   * Queues a callback for execution when SoundManager has successfully initialized.
   *
   * @param {function} oMethod The callback method to fire
   * @param {object} oScope Optional: The scope to apply to the callback
   */</span>

  <b>this</b>.onready = <b>function </b>(oMethod, oScope) {

    <b>var </b>sType = 'onready';

    <b>if </b>(oMethod && oMethod<b> instanceof </b>Function) {

<span class="singleComment">      // &lt;d&gt;</span>
      <b>if </b>(_didInit) {
        _s._wD(_str('queue', sType));
      }
<span class="singleComment">      // &lt;/d&gt;</span>

      <b>if </b>(!oScope) {
        oScope = _win;
      }

      _addOnEvent(sType, oMethod, oScope);
      _processOnEvents();

      <b>return</b> <b>true</b>;

    } <b>else </b>{

      <b>throw </b>_str('needFunction', sType);

    }

  };

<span class="multiComment">  /**
   * Queues a callback for execution when SoundManager has failed to initialize.
   *
   * @param {function} oMethod The callback method to fire
   * @param {object} oScope Optional: The scope to apply to the callback
   */</span>

  <b>this</b>.ontimeout = <b>function </b>(oMethod, oScope) {

    <b>var </b>sType = 'ontimeout';

    <b>if </b>(oMethod && oMethod<b> instanceof </b>Function) {

<span class="singleComment">      // &lt;d&gt;</span>
      <b>if </b>(_didInit) {
        _s._wD(_str('queue', sType));
      }
<span class="singleComment">      // &lt;/d&gt;</span>

      <b>if </b>(!oScope) {
        oScope = _win;
      }

      _addOnEvent(sType, oMethod, oScope);
      _processOnEvents({type:sType});

      <b>return</b> <b>true</b>;

    } <b>else </b>{

      <b>throw </b>_str('needFunction', sType);

    }

  };

<span class="multiComment">  /**
   * Writes console.log()-style debug output to a console or in-browser element.
   * Applies when SoundManager.debugMode = true
   *
   * @param {string} sText The console message
   * @param {string} sType Optional: Log type of 'info', 'warn' or 'error'
   * @param {object} Optional: The scope to apply to the callback
   */</span>

  <b>this</b>._writeDebug = <b>function </b>(sText, sType, _bTimestamp) {

<span class="singleComment">    // pseudo-private console.log()-style output</span>
<span class="singleComment">    // &lt;d&gt;</span>

    <b>var </b>sDID = 'soundmanager-debug', o, oItem, sMethod;

    <b>if </b>(!_s.debugMode) {
      <b>return</b> <b>false</b>;
    }

    <b>if </b>(<b>typeof </b>_bTimestamp !== 'undefined' && _bTimestamp) {
      sText = sText + ' | ' + <b>new </b>Date().getTime();
    }

    <b>if </b>(_hasConsole && _s.useConsole) {
      sMethod = _debugLevels[sType];
      <b>if </b>(<b>typeof </b>console[sMethod] !== 'undefined') {
        console[sMethod](sText);
      } <b>else </b>{
        console.log(sText);
      }
      <b>if </b>(_s.consoleOnly) {
        <b>return</b> <b>true</b>;
      }
    }

    <b>try </b>{

      o = _id(sDID);

      <b>if </b>(!o) {
        <b>return</b> <b>false</b>;
      }

      oItem = _doc.createElement('div');

      <b>if </b>(++_wdCount % 2 === 0) {
        oItem.className = 'sm2-alt';
      }

      <b>if </b>(<b>typeof </b>sType === 'undefined') {
        sType = 0;
      } <b>else </b>{
        sType = parseInt(sType, 10);
      }

      oItem.appendChild(_doc.createTextNode(sText));

      <b>if </b>(sType) {
        <b>if </b>(sType &gt;= 2) {
          oItem.style.fontWeight = 'bold';
        }
        <b>if </b>(sType === 3) {
          oItem.style.color = '#ff3333';
        }
      }

<span class="singleComment">      // top-to-bottom</span>
<span class="singleComment">      // o.appendChild(oItem);</span>

<span class="singleComment">      // bottom-to-top</span>
      o.insertBefore(oItem, o.firstChild);

    } <b>catch </b>(e) {
<span class="singleComment">      // oh well</span>
    }

    o = <b>null</b>;
<span class="singleComment">    // &lt;/d&gt;</span>

    <b>return</b> <b>true</b>;

  };

<span class="singleComment">  // alias</span>
  <b>this</b>._wD = <b>this</b>._writeDebug;

<span class="multiComment">  /**
   * Provides debug / state information on all SMSound objects.
   */</span>

  <b>this</b>._debug = <b>function </b>() {

<span class="singleComment">    // &lt;d&gt;</span>
    <b>var </b>i, j;
    _wDS('currentObj', 1);

    <b>for </b>(i = 0, j = _s.soundIDs.length; i &lt; j; i++) {
      _s.sounds[_s.soundIDs[i]]._debug();
    }
<span class="singleComment">    // &lt;/d&gt;</span>

  };

<span class="multiComment">  /**
   * Restarts and re-initializes the SoundManager instance.
   */</span>

  <b>this</b>.reboot = <b>function </b>() {

<span class="singleComment">    // attempt to reset and init SM2</span>
    _s._wD(_sm+'.reboot()');

<span class="singleComment">    // &lt;d&gt;</span>
    <b>if </b>(_s.soundIDs.length) {
      _s._wD('Destroying ' + _s.soundIDs.length + ' SMSound objects...');
    }
<span class="singleComment">    // &lt;/d&gt;</span>

    <b>var </b>i, j;

    <b>for </b>(i = _s.soundIDs.length-1; i &gt;= 0; i--) {
      _s.sounds[_s.soundIDs[i]].destruct();
    }

<span class="singleComment">    // trash ze flash</span>

    <b>try </b>{
      <b>if </b>(_isIE) {
        _oRemovedHTML = _flash.innerHTML;
      }
      _oRemoved = _flash.parentNode.removeChild(_flash);
      _s._wD('Flash movie removed.');
    } <b>catch </b>(e) {
<span class="singleComment">      // uh-oh.</span>
      _wDS('badRemove', 2);
    }

<span class="singleComment">    // actually, force recreate of movie.</span>
    _oRemovedHTML = _oRemoved = _needsFlash = <b>null</b>;

    _s.enabled = _didDCLoaded = _didInit = _waitingForEI = _initPending = _didAppend = _appendSuccess = _disabled = _s.swfLoaded = <b>false</b>;
    _s.soundIDs = [];
    _s.sounds = {};
    _flash = <b>null</b>;

    <b>for </b>(i<b> in </b>_on_queue) {
      <b>if </b>(_on_queue.hasOwnProperty(i)) {
        <b>for </b>(j = _on_queue[i].length-1; j &gt;= 0; j--) {
          _on_queue[i][j].fired = <b>false</b>;
        }
      }
    }

    _s._wD(_sm + ': Rebooting...');
    _win.setTimeout(_s.beginDelayedInit, 20);

  };

<span class="multiComment">  /**
   * Undocumented: Determines the SM2 flash movie's load progress.
   *
   * @return {number or null} Percent loaded, or if invalid/unsupported, null.
   */</span>

  <b>this</b>.getMoviePercent = <b>function </b>() {

    <b>return</b> (_flash && <b>typeof </b>_flash.PercentLoaded !== 'undefined' ? _flash.PercentLoaded() : <b>null</b>);

  };

<span class="multiComment">  /**
   * Additional helper for manually invoking SM2's init process after DOM Ready / window.onload().
   */</span>

  <b>this</b>.beginDelayedInit = <b>function </b>() {

    _windowLoaded = <b>true</b>;
    _domContentLoaded();

    setTimeout(<b>function </b>() {

      <b>if </b>(_initPending) {
        <b>return</b> <b>false</b>;
      }

      _createMovie();
      _initMovie();
      _initPending = <b>true</b>;

      <b>return</b> <b>true</b>;

    }, 20);

    _delayWaitForEI();

  };

<span class="multiComment">  /**
   * Destroys the SoundManager instance and all SMSound instances.
   */</span>

  <b>this</b>.destruct = <b>function </b>() {

    _s._wD(_sm+'.destruct()');
    _s.disable(<b>true</b>);

  };

<span class="multiComment">  /**
   * SMSound() (sound object) constructor
   * ------------------------------------
   *
   * @param {object} oOptions Sound options (id and url are required attributes)
   * @return {SMSound} The new SMSound object
   */</span>

  SMSound = <b>function </b>(oOptions) {

    <b>var </b>_t = <b>this</b>, _resetProperties, _add_html5_events, _remove_html5_events, _stop_html5_timer, _start_html5_timer, _attachOnPosition, _onplay_called = <b>false</b>, _onPositionItems = [], _onPositionFired = 0, _detachOnPosition, _applyFromTo, _lastURL = <b>null</b>, _lastHTML5State;

    _lastHTML5State = {
<span class="singleComment">      // tracks duration + position (time)</span>
      duration: <b>null</b>,
      time: <b>null</b>
    };

    <b>this</b>.sID = oOptions.id;
    <b>this</b>.url = oOptions.url;
    <b>this</b>.options = _mixin(oOptions);

<span class="singleComment">    // per-play-instance-specific options</span>
    <b>this</b>.instanceOptions = <b>this</b>.options;

<span class="singleComment">    // short alias</span>
    <b>this</b>._iO = <b>this</b>.instanceOptions;

<span class="singleComment">    // assign property defaults</span>
    <b>this</b>.pan = <b>this</b>.options.pan;
    <b>this</b>.volume = <b>this</b>.options.volume;
    <b>this</b>.isHTML5 = <b>false</b>;
    <b>this</b>._a = <b>null</b>;

<span class="multiComment">    /**
     * SMSound() public methods
     * ------------------------
     */</span>

    <b>this</b>.id3 = {};

<span class="multiComment">    /**
     * Writes SMSound object parameters to debug console
     */</span>

    <b>this</b>._debug = <b>function </b>() {

<span class="singleComment">      // &lt;d&gt;</span>
<span class="singleComment">      // pseudo-private console.log()-style output</span>

      <b>if </b>(_s.debugMode) {

        <b>var </b>stuff = <b>null</b>, msg = [], sF, sfBracket, maxLength = 64;

        <b>for </b>(stuff<b> in </b>_t.options) {
          <b>if </b>(_t.options[stuff] !== <b>null</b>) {
            <b>if </b>(_t.options[stuff]<b> instanceof </b>Function) {
<span class="singleComment">              // handle functions specially</span>
              sF = _t.options[stuff].toString();
<span class="singleComment">              // normalize spaces</span>
              sF = sF.replace(/\s\s+/g, ' ');
              sfBracket = sF.indexOf('{');
              msg.push(' ' + stuff + ': {' + sF.substr(sfBracket + 1, (Math.min(Math.max(sF.indexOf('\n') - 1, maxLength), maxLength))).replace(/\n/g, '') + '... }');
            } <b>else </b>{
              msg.push(' ' + stuff + ': ' + _t.options[stuff]);
            }
          }
        }

        _s._wD('SMSound() merged options: {\n' + msg.join(', \n') + '\n}');

      }
<span class="singleComment">      // &lt;/d&gt;</span>

    };

<span class="singleComment">    // &lt;d&gt;</span>
    <b>this</b>._debug();
<span class="singleComment">    // &lt;/d&gt;</span>

<span class="multiComment">    /**
     * Begins loading a sound per its *url*.
     *
     * @param {object} oOptions Optional: Sound options
     * @return {SMSound} The SMSound object
     */</span>

    <b>this</b>.load = <b>function </b>(oOptions) {

      <b>var </b>oS = <b>null</b>, _iO;

      <b>if </b>(<b>typeof </b>oOptions !== 'undefined') {
        _t._iO = _mixin(oOptions, _t.options);
        _t.instanceOptions = _t._iO;
      } <b>else </b>{
        oOptions = _t.options;
        _t._iO = oOptions;
        _t.instanceOptions = _t._iO;
        <b>if </b>(_lastURL && _lastURL !== _t.url) {
          _wDS('manURL');
          _t._iO.url = _t.url;
          _t.url = <b>null</b>;
        }
      }

      <b>if </b>(!_t._iO.url) {
        _t._iO.url = _t.url;
      }

      _t._iO.url = _parseURL(_t._iO.url);

      _s._wD('SMSound.load(): ' + _t._iO.url, 1);

      <b>if </b>(_t._iO.url === _t.url && _t.readyState !== 0 && _t.readyState !== 2) {
        _wDS('onURL', 1);
<span class="singleComment">        // if loaded and an onload() exists, fire immediately.</span>
        <b>if </b>(_t.readyState === 3 && _t._iO.onload) {
<span class="singleComment">          // assume success based on truthy duration.</span>
          _t._iO.onload.apply(_t, [(!!_t.duration)]);
        }
        <b>return</b> _t;
      }

<span class="singleComment">      // local shortcut</span>
      _iO = _t._iO;

      _lastURL = _t.url;
      _t.loaded = <b>false</b>;
      _t.readyState = 1;
      _t.playState = 0;

<span class="singleComment">      // TODO: If switching from HTML5 -&gt; flash (or vice versa), stop currently-playing audio.</span>

      <b>if </b>(_html5OK(_iO)) {

        oS = _t._setup_html5(_iO);

        <b>if </b>(!oS._called_load) {

          _s._wD(_h5+'load: '+_t.sID);
          _t._html5_canplay = <b>false</b>;

<span class="singleComment">          // given explicit load call, try to get whole file.</span>
<span class="singleComment">          // early HTML5 implementation (non-standard)</span>
          _t._a.autobuffer = 'auto';

<span class="singleComment">          // standard</span>
          _t._a.preload = 'auto';

          oS.load();
          oS._called_load = <b>true</b>;

          <b>if </b>(_iO.autoPlay) {
            _t.play();
          }

        } <b>else </b>{
          _s._wD(_h5+'ignoring request to load again: '+_t.sID);
        }

      } <b>else </b>{

        <b>try </b>{
          _t.isHTML5 = <b>false</b>;
          _t._iO = _policyFix(_loopFix(_iO));
<span class="singleComment">          // re-assign local shortcut</span>
          _iO = _t._iO;
          <b>if </b>(_fV === 8) {
            _flash._load(_t.sID, _iO.url, _iO.stream, _iO.autoPlay, (_iO.whileloading?1:0), _iO.loops||1, _iO.usePolicyFile);
          } <b>else </b>{
            _flash._load(_t.sID, _iO.url, !!(_iO.stream), !!(_iO.autoPlay), _iO.loops||1, !!(_iO.autoLoad), _iO.usePolicyFile);
          }
        } <b>catch </b>(e) {
          _wDS('smError', 2);
          _debugTS('onload', <b>false</b>);
          _catchError({type:'SMSOUND_LOAD_JS_EXCEPTION', fatal:<b>true</b>});

        }

      }

      <b>return</b> _t;

    };

<span class="multiComment">    /**
     * Unloads a sound, canceling any open HTTP requests.
     *
     * @return {SMSound} The SMSound object
     */</span>

    <b>this</b>.unload = <b>function </b>() {

<span class="singleComment">      // Flash 8/AS2 can't "close" a stream - fake it by loading an empty URL</span>
<span class="singleComment">      // Flash 9/AS3: Close stream, preventing further load</span>
<span class="singleComment">      // HTML5: Most UAs will use empty URL</span>

      <b>if </b>(_t.readyState !== 0) {

        _s._wD('SMSound.unload(): "' + _t.sID + '"');

        <b>if </b>(!_t.isHTML5) {
          <b>if </b>(_fV === 8) {
            _flash._unload(_t.sID, _emptyURL);
          } <b>else </b>{
            _flash._unload(_t.sID);
          }
        } <b>else </b>{
          _stop_html5_timer();
          <b>if </b>(_t._a) {
            _t._a.pause();
            _html5Unload(_t._a);
          }
        }

<span class="singleComment">        // reset load/status flags</span>
        _resetProperties();

      }

      <b>return</b> _t;

    };

<span class="multiComment">    /**
     * Unloads and destroys a sound.
     */</span>

    <b>this</b>.destruct = <b>function </b>(_bFromSM) {

      _s._wD('SMSound.destruct(): "' + _t.sID + '"');

      <b>if </b>(!_t.isHTML5) {

<span class="singleComment">        // kill sound within Flash</span>
<span class="singleComment">        // Disable the onfailure handler</span>
        _t._iO.onfailure = <b>null</b>;
        _flash._destroySound(_t.sID);

      } <b>else </b>{

        _stop_html5_timer();

        <b>if </b>(_t._a) {
          _t._a.pause();
          _html5Unload(_t._a);
          <b>if </b>(!_useGlobalHTML5Audio) {
            _remove_html5_events();
          }
<span class="singleComment">          // break obvious circular reference</span>
          _t._a._t = <b>null</b>;
          _t._a = <b>null</b>;
        }

      }

      <b>if </b>(!_bFromSM) {
<span class="singleComment">        // ensure deletion from controller</span>
        _s.destroySound(_t.sID, <b>true</b>);

      }

    };

<span class="multiComment">    /**
     * Begins playing a sound.
     *
     * @param {object} oOptions Optional: Sound options
     * @return {SMSound} The SMSound object
     */</span>

    <b>this</b>.play = <b>function </b>(oOptions, _updatePlayState) {

      <b>var </b>fN, allowMulti, a, onready;

<span class="singleComment">      // &lt;d&gt;</span>
      fN = 'SMSound.play(): ';
<span class="singleComment">      // &lt;/d&gt;</span>

      _updatePlayState = _updatePlayState === undefined ? <b>true</b> : _updatePlayState; // <b>default </b>to <b>true</b>

      <b>if </b>(!oOptions) {
        oOptions = {};
      }

      _t._iO = _mixin(oOptions, _t._iO);
      _t._iO = _mixin(_t._iO, _t.options);
      _t._iO.url = _parseURL(_t._iO.url);
      _t.instanceOptions = _t._iO;

<span class="singleComment">      // RTMP-only</span>
      <b>if </b>(_t._iO.serverURL && !_t.connected) {
        <b>if </b>(!_t.getAutoPlay()) {
          _s._wD(fN+' Netstream not connected yet - setting autoPlay');
          _t.setAutoPlay(<b>true</b>);
        }
<span class="singleComment">        // play will be called in _onconnect()</span>
        <b>return</b> _t;
      }

      <b>if </b>(_html5OK(_t._iO)) {
        _t._setup_html5(_t._iO);
        _start_html5_timer();
      }

      <b>if </b>(_t.playState === 1 && !_t.paused) {
        allowMulti = _t._iO.multiShot;
        <b>if </b>(!allowMulti) {
          _s._wD(fN + '"' + _t.sID + '" already playing (one-shot)', 1);
          <b>return</b> _t;
        } <b>else </b>{
          _s._wD(fN + '"' + _t.sID + '" already playing (multi-shot)', 1);
        }
      }

      <b>if </b>(!_t.loaded) {

        <b>if </b>(_t.readyState === 0) {

          _s._wD(fN + 'Attempting to load "' + _t.sID + '"', 1);

<span class="singleComment">          // try to get this sound playing ASAP</span>
          <b>if </b>(!_t.isHTML5) {
<span class="singleComment">            // assign directly because setAutoPlay() increments the instanceCount</span>
            _t._iO.autoPlay = <b>true</b>;
          }

          _t.load(_t._iO);

        } <b>else </b><b>if </b>(_t.readyState === 2) {

          _s._wD(fN + 'Could not load "' + _t.sID + '" - exiting', 2);
          <b>return</b> _t;

        } <b>else </b>{

          _s._wD(fN + '"' + _t.sID + '" is loading - attempting to play..', 1);

        }

      } <b>else </b>{

        _s._wD(fN + '"' + _t.sID + '"');

      }

      <b>if </b>(!_t.isHTML5 && _fV === 9 && _t.position &gt; 0 && _t.position === _t.duration) {
<span class="singleComment">        // flash 9 needs a position reset if play() is called while at the end of a sound.</span>
        _s._wD(fN + '"' + _t.sID + '": Sound at end, resetting to position:0');
        oOptions.position = 0;
      }

<span class="multiComment">      /**
       * Streams will pause when their buffer is full if they are being loaded.
       * In this case paused is true, but the song hasn't started playing yet.
       * If we just call resume() the onplay() callback will never be called.
       * So only call resume() if the position is &gt; 0.
       * Another reason is because options like volume won't have been applied yet.
       */</span>

      <b>if </b>(_t.paused && _t.position && _t.position &gt; 0) {

<span class="singleComment">        // https://gist.github.com/37b17df75cc4d7a90bf6</span>
        _s._wD(fN + '"' + _t.sID + '" is resuming from paused state',1);
        _t.resume();

      } <b>else </b>{

        _t._iO = _mixin(oOptions, _t._iO);

<span class="singleComment">        // apply from/to parameters, if they exist (and not using RTMP)</span>
        <b>if </b>(_t._iO.from !== <b>null</b> && _t._iO.to !== <b>null</b> && _t.instanceCount === 0 && _t.playState === 0 && !_t._iO.serverURL) {

          onready = <b>function </b>() {
<span class="singleComment">            // sound "canplay" or onload()</span>
<span class="singleComment">            // re-apply from/to to instance options, and start playback</span>
            _t._iO = _mixin(oOptions, _t._iO);
            _t.play(_t._iO);
          };

<span class="singleComment">          // HTML5 needs to at least have "canplay" fired before seeking.</span>
          <b>if </b>(_t.isHTML5 && !_t._html5_canplay) {

<span class="singleComment">            // this hasn't been loaded yet. load it first, and then do this again.</span>
            _s._wD(fN+'Beginning load of "'+ _t.sID+'" for from/to case');

            _t.load({
              _oncanplay: onready
            });

            <b>return</b> <b>false</b>;

          } <b>else </b><b>if </b>(!_t.isHTML5 && !_t.loaded && (!_t.readyState || _t.readyState !== 2)) {

<span class="singleComment">            // to be safe, preload the whole thing in Flash.</span>

            _s._wD(fN+'Preloading "'+ _t.sID+'" for from/to case');

            _t.load({
              onload: onready
            });

            <b>return</b> <b>false</b>;

          }

<span class="singleComment">          // otherwise, we're ready to go. re-apply local options, and continue</span>

          _t._iO = _applyFromTo();

        }

        _s._wD(fN+'"'+ _t.sID+'" is starting to play');

        <b>if </b>(!_t.instanceCount || _t._iO.multiShotEvents || (!_t.isHTML5 && _fV &gt; 8 && !_t.getAutoPlay())) {
          _t.instanceCount++;
        }

<span class="singleComment">        // if first play and onposition parameters exist, apply them now</span>
        <b>if </b>(_t.playState === 0 && _t._iO.onposition) {
          _attachOnPosition(_t);
        }

        _t.playState = 1;
        _t.paused = <b>false</b>;

        _t.position = (<b>typeof </b>_t._iO.position !== 'undefined' && !isNaN(_t._iO.position) ? _t._iO.position : 0);

        <b>if </b>(!_t.isHTML5) {
          _t._iO = _policyFix(_loopFix(_t._iO));
        }

        <b>if </b>(_t._iO.onplay && _updatePlayState) {
          _t._iO.onplay.apply(_t);
          _onplay_called = <b>true</b>;
        }

        _t.setVolume(_t._iO.volume, <b>true</b>);
        _t.setPan(_t._iO.pan, <b>true</b>);

        <b>if </b>(!_t.isHTML5) {

          _flash._start(_t.sID, _t._iO.loops || 1, (_fV === 9?_t._iO.position:_t._iO.position / 1000));

        } <b>else </b>{

          _start_html5_timer();
          a = _t._setup_html5();
          _t.setPosition(_t._iO.position);
          a.play();

        }

      }

      <b>return</b> _t;

    };

<span class="singleComment">    // just for convenience</span>
    <b>this</b>.start = <b>this</b>.play;

<span class="multiComment">    /**
     * Stops playing a sound (and optionally, all sounds)
     *
     * @param {boolean} bAll Optional: Whether to stop all sounds
     * @return {SMSound} The SMSound object
     */</span>

    <b>this</b>.stop = <b>function </b>(bAll) {

      <b>var </b>_iO = _t._iO, _oP;

      <b>if </b>(_t.playState === 1) {

        _t._onbufferchange(0);
        _t._resetOnPosition(0);
        _t.paused = <b>false</b>;

        <b>if </b>(!_t.isHTML5) {
          _t.playState = 0;
        }

<span class="singleComment">        // remove onPosition listeners, if any</span>
        _detachOnPosition();

<span class="singleComment">        // and "to" position, if set</span>
        <b>if </b>(_iO.to) {
          _t.clearOnPosition(_iO.to);
        }

        <b>if </b>(!_t.isHTML5) {

          _flash._stop(_t.sID, bAll);

<span class="singleComment">          // hack for netStream: just unload</span>
          <b>if </b>(_iO.serverURL) {
            _t.unload();
          }

        } <b>else </b>{

          <b>if </b>(_t._a) {

            _oP = _t.position;

<span class="singleComment">            // act like Flash, though</span>
            _t.setPosition(0);

<span class="singleComment">            // hack: reflect old position for onstop() (also like Flash)</span>
            _t.position = _oP;

<span class="singleComment">            // html5 has no stop()</span>
<span class="singleComment">            // NOTE: pausing means iOS requires interaction to resume.</span>
            _t._a.pause();

            _t.playState = 0;

<span class="singleComment">            // and update UI</span>
            _t._onTimer();

            _stop_html5_timer();

          }

        }

        _t.instanceCount = 0;
        _t._iO = {};

        <b>if </b>(_iO.onstop) {
          _iO.onstop.apply(_t);
        }

      }

      <b>return</b> _t;

    };

<span class="multiComment">    /**
     * Undocumented/internal: Sets autoPlay for RTMP.
     *
     * @param {boolean} autoPlay state
     */</span>

    <b>this</b>.setAutoPlay = <b>function </b>(autoPlay) {

      _s._wD('sound '+_t.sID+' turned autoplay ' + (autoPlay ? 'on' : 'off'));
      _t._iO.autoPlay = autoPlay;

      <b>if </b>(!_t.isHTML5) {
        _flash._setAutoPlay(_t.sID, autoPlay);
        <b>if </b>(autoPlay) {
<span class="singleComment">          // only increment the instanceCount if the sound isn't loaded (TODO: verify RTMP)</span>
          <b>if </b>(!_t.instanceCount && _t.readyState === 1) {
            _t.instanceCount++;
            _s._wD('sound '+_t.sID+' incremented instance count to '+_t.instanceCount);
          }
        }
      }

    };

<span class="multiComment">    /**
     * Undocumented/internal: Returns the autoPlay boolean.
     *
     * @return {boolean} The current autoPlay value
     */</span>

    <b>this</b>.getAutoPlay = <b>function </b>() {

      <b>return</b> _t._iO.autoPlay;

    };

<span class="multiComment">    /**
     * Sets the position of a sound.
     *
     * @param {number} nMsecOffset Position (milliseconds)
     * @return {SMSound} The SMSound object
     */</span>

    <b>this</b>.setPosition = <b>function </b>(nMsecOffset) {

      <b>if </b>(nMsecOffset === undefined) {
        nMsecOffset = 0;
      }

      <b>var </b>original_pos,
          position, position1K,
<span class="singleComment">          // Use the duration from the instance options, if we don't have a track duration yet.</span>
<span class="singleComment">          // position &gt;= 0 and &lt;= current available (loaded) duration</span>
          offset = (_t.isHTML5 ? Math.max(nMsecOffset,0) : Math.min(_t.duration || _t._iO.duration, Math.max(nMsecOffset, 0)));

      original_pos = _t.position;
      _t.position = offset;
      position1K = _t.position/1000;
      _t._resetOnPosition(_t.position);
      _t._iO.position = offset;

      <b>if </b>(!_t.isHTML5) {

        position = (_fV === 9 ? _t.position : position1K);
        <b>if </b>(_t.readyState && _t.readyState !== 2) {
<span class="singleComment">          // if paused or not playing, will not resume (by playing)</span>
          _flash._setPosition(_t.sID, position, (_t.paused || !_t.playState));
        }

      } <b>else </b><b>if </b>(_t._a) {

<span class="singleComment">        // Set the position in the canplay handler if the sound is not ready yet</span>
        <b>if </b>(_t._html5_canplay) {
          <b>if </b>(_t._a.currentTime !== position1K) {
<span class="multiComment">            /**
             * DOM/JS errors/exceptions to watch out for:
             * if seek is beyond (loaded?) position, "DOM exception 11"
             * "INDEX_SIZE_ERR": DOM exception 1
             */</span>
            _s._wD('setPosition('+position1K+'): setting position');
            <b>try </b>{
              _t._a.currentTime = position1K;
              <b>if </b>(_t.playState === 0 || _t.paused) {
<span class="singleComment">                // allow seek without auto-play/resume</span>
                _t._a.pause();
              }
            } <b>catch </b>(e) {
              _s._wD('setPosition('+position1K+'): setting position failed: '+e.message, 2);
            }
          }
        } <b>else </b>{
          _s._wD('setPosition('+position1K+'): delaying, sound not ready');
        }

      }

      <b>if </b>(_t.isHTML5) {
        <b>if </b>(_t.paused) {
<span class="singleComment">          // if paused, refresh UI right away</span>
<span class="singleComment">          // force update</span>
          _t._onTimer(<b>true</b>);
        }
      }

      <b>return</b> _t;

    };

<span class="multiComment">    /**
     * Pauses sound playback.
     *
     * @return {SMSound} The SMSound object
     */</span>

    <b>this</b>.pause = <b>function </b>(_bCallFlash) {

      <b>if </b>(_t.paused || (_t.playState === 0 && _t.readyState !== 1)) {
        <b>return</b> _t;
      }

      _s._wD('SMSound.pause()');
      _t.paused = <b>true</b>;

      <b>if </b>(!_t.isHTML5) {
        <b>if </b>(_bCallFlash || _bCallFlash === undefined) {
          _flash._pause(_t.sID);
        }
      } <b>else </b>{
        _t._setup_html5().pause();
        _stop_html5_timer();
      }

      <b>if </b>(_t._iO.onpause) {
        _t._iO.onpause.apply(_t);
      }

      <b>return</b> _t;

    };

<span class="multiComment">    /**
     * Resumes sound playback.
     *
     * @return {SMSound} The SMSound object
     */</span>

<span class="multiComment">    /**
     * When auto-loaded streams pause on buffer full they have a playState of 0.
     * We need to make sure that the playState is set to 1 when these streams "resume".
     * When a paused stream is resumed, we need to trigger the onplay() callback if it
     * hasn't been called already. In this case since the sound is being played for the
     * first time, I think it's more appropriate to call onplay() rather than onresume().
     */</span>

    <b>this</b>.resume = <b>function </b>() {

      <b>var </b>_iO = _t._iO;

      <b>if </b>(!_t.paused) {
        <b>return</b> _t;
      }

      _s._wD('SMSound.resume()');
      _t.paused = <b>false</b>;
      _t.playState = 1;

      <b>if </b>(!_t.isHTML5) {
        <b>if </b>(_iO.isMovieStar && !_iO.serverURL) {
<span class="singleComment">          // Bizarre Webkit bug (Chrome reported via 8tracks.com dudes): AAC content paused for 30+ seconds(?) will not resume without a reposition.</span>
          _t.setPosition(_t.position);
        }
<span class="singleComment">        // flash method is toggle-based (pause/resume)</span>
        _flash._pause(_t.sID);
      } <b>else </b>{
        _t._setup_html5().play();
        _start_html5_timer();
      }

      <b>if </b>(!_onplay_called && _iO.onplay) {
        _iO.onplay.apply(_t);
        _onplay_called = <b>true</b>;
      } <b>else </b><b>if </b>(_iO.onresume) {
        _iO.onresume.apply(_t);
      }

      <b>return</b> _t;

    };

<span class="multiComment">    /**
     * Toggles sound playback.
     *
     * @return {SMSound} The SMSound object
     */</span>

    <b>this</b>.togglePause = <b>function </b>() {

      _s._wD('SMSound.togglePause()');

      <b>if </b>(_t.playState === 0) {
        _t.play({
          position: (_fV === 9 && !_t.isHTML5 ? _t.position : _t.position / 1000)
        });
        <b>return</b> _t;
      }

      <b>if </b>(_t.paused) {
        _t.resume();
      } <b>else </b>{
        _t.pause();
      }

      <b>return</b> _t;

    };

<span class="multiComment">    /**
     * Sets the panning (L-R) effect.
     *
     * @param {number} nPan The pan value (-100 to 100)
     * @return {SMSound} The SMSound object
     */</span>

    <b>this</b>.setPan = <b>function </b>(nPan, bInstanceOnly) {

      <b>if </b>(<b>typeof </b>nPan === 'undefined') {
        nPan = 0;
      }

      <b>if </b>(<b>typeof </b>bInstanceOnly === 'undefined') {
        bInstanceOnly = <b>false</b>;
      }

      <b>if </b>(!_t.isHTML5) {
        _flash._setPan(_t.sID, nPan);
      } // <b>else </b>{ no HTML5 pan? }

      _t._iO.pan = nPan;

      <b>if </b>(!bInstanceOnly) {
        _t.pan = nPan;
        _t.options.pan = nPan;
      }

      <b>return</b> _t;

    };

<span class="multiComment">    /**
     * Sets the volume.
     *
     * @param {number} nVol The volume value (0 to 100)
     * @return {SMSound} The SMSound object
     */</span>

    <b>this</b>.setVolume = <b>function </b>(nVol, _bInstanceOnly) {

<span class="multiComment">      /**
       * Note: Setting volume has no effect on iOS "special snowflake" devices.
       * Hardware volume control overrides software, and volume
       * will always return 1 per Apple docs. (iOS 4 + 5.)
       * http://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/AddingSoundtoCanvasAnimations/AddingSoundtoCanvasAnimations.html
       */</span>

      <b>if </b>(<b>typeof </b>nVol === 'undefined') {
        nVol = 100;
      }

      <b>if </b>(<b>typeof </b>_bInstanceOnly === 'undefined') {
        _bInstanceOnly = <b>false</b>;
      }

      <b>if </b>(!_t.isHTML5) {
        _flash._setVolume(_t.sID, (_s.muted && !_t.muted) || _t.muted?0:nVol);
      } <b>else </b><b>if </b>(_t._a) {
<span class="singleComment">        // valid range: 0-1</span>
        _t._a.volume = Math.max(0, Math.min(1, nVol/100));
      }

      _t._iO.volume = nVol;

      <b>if </b>(!_bInstanceOnly) {
        _t.volume = nVol;
        _t.options.volume = nVol;
      }

      <b>return</b> _t;

    };

<span class="multiComment">    /**
     * Mutes the sound.
     *
     * @return {SMSound} The SMSound object
     */</span>

    <b>this</b>.mute = <b>function </b>() {

      _t.muted = <b>true</b>;

      <b>if </b>(!_t.isHTML5) {
        _flash._setVolume(_t.sID, 0);
      } <b>else </b><b>if </b>(_t._a) {
        _t._a.muted = <b>true</b>;
      }

      <b>return</b> _t;

    };

<span class="multiComment">    /**
     * Unmutes the sound.
     *
     * @return {SMSound} The SMSound object
     */</span>

    <b>this</b>.unmute = <b>function </b>() {

      _t.muted = <b>false</b>;
      <b>var </b>hasIO = <b>typeof </b>_t._iO.volume !== 'undefined';

      <b>if </b>(!_t.isHTML5) {
        _flash._setVolume(_t.sID, hasIO?_t._iO.volume:_t.options.volume);
      } <b>else </b><b>if </b>(_t._a) {
        _t._a.muted = <b>false</b>;
      }

      <b>return</b> _t;

    };

<span class="multiComment">    /**
     * Toggles the muted state of a sound.
     *
     * @return {SMSound} The SMSound object
     */</span>

    <b>this</b>.toggleMute = <b>function </b>() {

      <b>return</b> (_t.muted?_t.unmute():_t.mute());

    };

<span class="multiComment">    /**
     * Registers a callback to be fired when a sound reaches a given position during playback.
     *
     * @param {number} nPosition The position to watch for
     * @param {function} oMethod The relevant callback to fire
     * @param {object} oScope Optional: The scope to apply the callback to
     * @return {SMSound} The SMSound object
     */</span>

    <b>this</b>.onPosition = <b>function </b>(nPosition, oMethod, oScope) {

<span class="singleComment">      // TODO: basic dupe checking?</span>

      _onPositionItems.push({
        position: parseInt(nPosition, 10),
        method: oMethod,
        scope: (<b>typeof </b>oScope !== 'undefined' ? oScope : _t),
        fired: <b>false</b>
      });

      <b>return</b> _t;

    };

<span class="singleComment">    // legacy/backwards-compability: lower-case method name</span>
    <b>this</b>.onposition = <b>this</b>.onPosition;

<span class="multiComment">    /**
     * Removes registered callback(s) from a sound, by position and/or callback.
     *
     * @param {number} nPosition The position to clear callback(s) for
     * @param {function} oMethod Optional: Identify one callback to be removed when multiple listeners exist for one position
     * @return {SMSound} The SMSound object
     */</span>

    <b>this</b>.clearOnPosition = <b>function </b>(nPosition, oMethod) {

      <b>var </b>i;

      nPosition = parseInt(nPosition, 10);

      <b>if </b>(isNaN(nPosition)) {
<span class="singleComment">        // safety check</span>
        <b>return</b> <b>false</b>;
      }

      <b>for </b>(i=0; i &lt; _onPositionItems.length; i++) {

        <b>if </b>(nPosition === _onPositionItems[i].position) {
<span class="singleComment">          // remove this item if no method was specified, or, if the method matches</span>
          <b>if </b>(!oMethod || (oMethod === _onPositionItems[i].method)) {
            <b>if </b>(_onPositionItems[i].fired) {
<span class="singleComment">              // decrement "fired" counter, too</span>
              _onPositionFired--;
            }
            _onPositionItems.splice(i, 1);
          }
        }

      }

    };

    <b>this</b>._processOnPosition = <b>function </b>() {

      <b>var </b>i, item, j = _onPositionItems.length;

      <b>if </b>(!j || !_t.playState || _onPositionFired &gt;= j) {
        <b>return</b> <b>false</b>;
      }

      <b>for </b>(i=j-1; i &gt;= 0; i--) {
        item = _onPositionItems[i];
        <b>if </b>(!item.fired && _t.position &gt;= item.position) {
          item.fired = <b>true</b>;
          _onPositionFired++;
          item.method.apply(item.scope, [item.position]);
        }
      }

      <b>return</b> <b>true</b>;

    };

    <b>this</b>._resetOnPosition = <b>function </b>(nPosition) {

<span class="singleComment">      // reset "fired" for items interested in this position</span>
      <b>var </b>i, item, j = _onPositionItems.length;

      <b>if </b>(!j) {
        <b>return</b> <b>false</b>;
      }

      <b>for </b>(i=j-1; i &gt;= 0; i--) {
        item = _onPositionItems[i];
        <b>if </b>(item.fired && nPosition &lt;= item.position) {
          item.fired = <b>false</b>;
          _onPositionFired--;
        }
      }

      <b>return</b> <b>true</b>;

    };

<span class="multiComment">    /**
     * SMSound() private internals
     * --------------------------------
     */</span>

    _applyFromTo = <b>function </b>() {

      <b>var </b>_iO = _t._iO,
          f = _iO.from,
          t = _iO.to,
          start, end;

      end = <b>function </b>() {

<span class="singleComment">        // end has been reached.</span>
        _s._wD(_t.sID + ': "to" time of ' + t + ' reached.');

<span class="singleComment">        // detach listener</span>
        _t.clearOnPosition(t, end);

<span class="singleComment">        // stop should clear this, too</span>
        _t.stop();

      };

      start = <b>function </b>() {

        _s._wD(_t.sID + ': playing "from" ' + f);

<span class="singleComment">        // add listener for end</span>
        <b>if </b>(t !== <b>null</b> && !isNaN(t)) {
          _t.onPosition(t, end);
        }

      };

      <b>if </b>(f !== <b>null</b> && !isNaN(f)) {

<span class="singleComment">        // apply to instance options, guaranteeing correct start position.</span>
        _iO.position = f;

<span class="singleComment">        // multiShot timing can't be tracked, so prevent that.</span>
        _iO.multiShot = <b>false</b>;

        start();

      }

<span class="singleComment">      // return updated instanceOptions including starting position</span>
      <b>return</b> _iO;

    };

    _attachOnPosition = <b>function </b>() {

      <b>var </b>item,
          op = _t._iO.onposition;

<span class="singleComment">      // attach onposition things, if any, now.</span>

      <b>if </b>(op) {

        <b>for </b>(item<b> in </b>op) {
          <b>if </b>(op.hasOwnProperty(item)) {
            _t.onPosition(parseInt(item, 10), op[item]); 
          }
        }

      }

    };

    _detachOnPosition = <b>function </b>() {

      <b>var </b>item,
          op = _t._iO.onposition;

<span class="singleComment">      // detach any onposition()-style listeners.</span>

      <b>if </b>(op) {

        <b>for </b>(item<b> in </b>op) {
          <b>if </b>(op.hasOwnProperty(item)) {
            _t.clearOnPosition(parseInt(item, 10));
          }
        }

      }

    };

    _start_html5_timer = <b>function </b>() {

      <b>if </b>(_t.isHTML5) {
        _startTimer(_t);
      }

    };

    _stop_html5_timer = <b>function </b>() {

      <b>if </b>(_t.isHTML5) {
        _stopTimer(_t);
      }

    };

    _resetProperties = <b>function </b>() {

      _onPositionItems = [];
      _onPositionFired = 0;
      _onplay_called = <b>false</b>;

      _t._hasTimer = <b>null</b>;
      _t._a = <b>null</b>;
      _t._html5_canplay = <b>false</b>;
      _t.bytesLoaded = <b>null</b>;
      _t.bytesTotal = <b>null</b>;
      _t.duration = (_t._iO && _t._iO.duration ? _t._iO.duration : <b>null</b>);
      _t.durationEstimate = <b>null</b>;

<span class="singleComment">      // legacy: 1D array</span>
      _t.eqData = [];

      _t.eqData.left = [];
      _t.eqData.right = [];

      _t.failures = 0;
      _t.isBuffering = <b>false</b>;
      _t.instanceOptions = {};
      _t.instanceCount = 0;
      _t.loaded = <b>false</b>;
      _t.metadata = {};

<span class="singleComment">      // 0 = uninitialised, 1 = loading, 2 = failed/error, 3 = loaded/success</span>
      _t.readyState = 0;

      _t.muted = <b>false</b>;
      _t.paused = <b>false</b>;

      _t.peakData = {
        left: 0,
        right: 0
      };

      _t.waveformData = {
        left: [],
        right: []
      };

      _t.playState = 0;
      _t.position = <b>null</b>;

    };

    _resetProperties();

<span class="multiComment">    /**
     * Pseudo-private SMSound internals
     * --------------------------------
     */</span>

    <b>this</b>._onTimer = <b>function </b>(bForce) {

<span class="multiComment">      /**
       * HTML5-only _whileplaying() etc.
       * called from both HTML5 native events, and polling/interval-based timers
       * mimics flash and fires only when time/duration change, so as to be polling-friendly
       */</span>

      <b>var </b>duration, isNew = <b>false</b>, time, x = {};

      <b>if </b>(_t._hasTimer || bForce) {

<span class="singleComment">        // TODO: May not need to track readyState (1 = loading)</span>

        <b>if </b>(_t._a && (bForce || ((_t.playState &gt; 0 || _t.readyState === 1) && !_t.paused))) {

          duration = _t._get_html5_duration();

          <b>if </b>(duration !== _lastHTML5State.duration) {

            _lastHTML5State.duration = duration;
            _t.duration = duration;
            isNew = <b>true</b>;

          }

<span class="singleComment">          // TODO: investigate why this goes wack if not set/re-set each time.</span>
          _t.durationEstimate = _t.duration;

          time = (_t._a.currentTime * 1000 || 0);

          <b>if </b>(time !== _lastHTML5State.time) {

            _lastHTML5State.time = time;
            isNew = <b>true</b>;

          }

          <b>if </b>(isNew || bForce) {

            _t._whileplaying(time,x,x,x,x);

          }

          <b>return</b> isNew;

        } <b>else </b>{

<span class="singleComment">          // _s._wD('_onTimer: Warn for "'+_t.sID+'": '+(!_t._a?'Could not find element. ':'')+(_t.playState === 0?'playState bad, 0?':'playState = '+_t.playState+', OK'));</span>

          <b>return</b> <b>false</b>;

        }

      }

    };

    <b>this</b>._get_html5_duration = <b>function </b>() {

      <b>var </b>_iO = _t._iO,
          d = (_t._a ? _t._a.duration*1000 : (_iO ? _iO.duration : undefined)),
          result = (d && !isNaN(d) && d !== Infinity ? d : (_iO ? _iO.duration : <b>null</b>));

      <b>return</b> result;

    };

    <b>this</b>._setup_html5 = <b>function </b>(oOptions) {

      <b>var </b>_iO = _mixin(_t._iO, oOptions), d = decodeURI,
          _a = _useGlobalHTML5Audio ? _s._global_a : _t._a,
          _dURL = d(_iO.url),
          _oldIO = (_a && _a._t ? _a._t.instanceOptions : <b>null</b>);

      <b>if </b>(_a) {

        <b>if </b>(_a._t) {

          <b>if </b>(!_useGlobalHTML5Audio && _dURL === d(_lastURL)) {
<span class="singleComment">            // same url, ignore request</span>
            <b>return</b> _a; 
          } <b>else </b><b>if </b>(_useGlobalHTML5Audio && _oldIO.url === _iO.url && (!_lastURL || (_lastURL === _oldIO.url))) {
<span class="singleComment">            // iOS-type reuse case</span>
            <b>return</b> _a;
          }

        }

        _s._wD('setting <b>new </b>URL on existing object: ' + _dURL + (_lastURL ? ', old URL: ' + _lastURL : ''));

<span class="multiComment">        /**
         * "First things first, I, Poppa.." (reset the previous state of the old sound, if playing)
         * Fixes case with devices that can only play one sound at a time
         * Otherwise, other sounds in mid-play will be terminated without warning and in a stuck state
         */</span>

        <b>if </b>(_useGlobalHTML5Audio && _a._t && _a._t.playState && _iO.url !== _oldIO.url) {
          _a._t.stop();
        }

<span class="singleComment">        // new URL, so reset load/playstate and so on</span>
        _resetProperties();

        _a.src = _iO.url;
        _t.url = _iO.url;
        _lastURL = _iO.url;
        _a._called_load = <b>false</b>;

      } <b>else </b>{

        _s._wD('creating HTML5 Audio() element with URL: '+_dURL);
        _a = <b>new </b>Audio(_iO.url);

        _a._called_load = <b>false</b>;

<span class="singleComment">        // android (seen in 2.3/Honeycomb) sometimes fails first .load() -&gt; .play(), results in playback failure and ended() events?</span>
        <b>if </b>(_is_android) {
          _a._called_load = <b>true</b>;
        }

        <b>if </b>(_useGlobalHTML5Audio) {
          _s._global_a = _a;
        }

      }

      _t.isHTML5 = <b>true</b>;

<span class="singleComment">      // store a ref on the track</span>
      _t._a = _a;

<span class="singleComment">      // store a ref on the audio</span>
      _a._t = _t;

      _add_html5_events();
      _a.loop = (_iO.loops&gt;1?'loop':'');

      <b>if </b>(_iO.autoLoad || _iO.autoPlay) {

        _t.load();

      } <b>else </b>{

<span class="singleComment">        // early HTML5 implementation (non-standard)</span>
        _a.autobuffer = <b>false</b>;

<span class="singleComment">        // standard</span>
        _a.preload = 'none';

      }

<span class="singleComment">      // boolean instead of "loop", for webkit? - spec says string. http://www.w3.org/TR/html-markup/audio.html#audio.attrs.loop</span>
      _a.loop = (_iO.loops &gt; 1 ? 'loop' : '');

      <b>return</b> _a;

    };

    _add_html5_events = <b>function </b>() {

      <b>if </b>(_t._a._added_events) {
        <b>return</b> <b>false</b>;
      }

      <b>var </b>f;

      function add(oEvt, oFn, bCapture) {
        <b>return</b> _t._a ? _t._a.addEventListener(oEvt, oFn, bCapture||<b>false</b>) : <b>null</b>;
      }

      _s._wD(_h5+'adding event listeners: '+_t.sID);
      _t._a._added_events = <b>true</b>;

      <b>for </b>(f<b> in </b>_html5_events) {
        <b>if </b>(_html5_events.hasOwnProperty(f)) {
          add(f, _html5_events[f]);
        }
      }

      <b>return</b> <b>true</b>;

    };

    _remove_html5_events = <b>function </b>() {

<span class="singleComment">      // Remove event listeners</span>

      <b>var </b>f;

      function remove(oEvt, oFn, bCapture) {
        <b>return</b> (_t._a ? _t._a.removeEventListener(oEvt, oFn, bCapture||<b>false</b>) : <b>null</b>);
      }

      _s._wD(_h5+'removing event listeners: '+_t.sID);
      _t._a._added_events = <b>false</b>;

      <b>for </b>(f<b> in </b>_html5_events) {
        <b>if </b>(_html5_events.hasOwnProperty(f)) {
          remove(f, _html5_events[f]);
        }
      }

    };

<span class="multiComment">    /**
     * Pseudo-private event internals
     * ------------------------------
     */</span>

    <b>this</b>._onload = <b>function </b>(nSuccess) {


      <b>var </b>fN, loadOK = !!(nSuccess);

<span class="singleComment">      // &lt;d&gt;</span>
      fN = 'SMSound._onload(): ';
      _s._wD(fN + '"' + _t.sID + '"' + (loadOK?' loaded.':' failed to load? - ' + _t.url), (loadOK?1:2));
      <b>if </b>(!loadOK && !_t.isHTML5) {
        <b>if </b>(_s.sandbox.noRemote === <b>true</b>) {
          _s._wD(fN + _str('noNet'), 1);
        }
        <b>if </b>(_s.sandbox.noLocal === <b>true</b>) {
          _s._wD(fN + _str('noLocal'), 1);
        }
      }
<span class="singleComment">      // &lt;/d&gt;</span>

      _t.loaded = loadOK;
      _t.readyState = loadOK?3:2;
      _t._onbufferchange(0);

      <b>if </b>(_t._iO.onload) {
        _t._iO.onload.apply(_t, [loadOK]);
      }

      <b>return</b> <b>true</b>;

    };

    <b>this</b>._onbufferchange = <b>function </b>(nIsBuffering) {

      <b>if </b>(_t.playState === 0) {
<span class="singleComment">        // ignore if not playing</span>
        <b>return</b> <b>false</b>;
      }

      <b>if </b>((nIsBuffering && _t.isBuffering) || (!nIsBuffering && !_t.isBuffering)) {
        <b>return</b> <b>false</b>;
      }

      _t.isBuffering = (nIsBuffering === 1);
      <b>if </b>(_t._iO.onbufferchange) {
        _s._wD('SMSound._onbufferchange(): ' + nIsBuffering);
        _t._iO.onbufferchange.apply(_t);
      }

      <b>return</b> <b>true</b>;

    };

<span class="multiComment">    /**
     * Notify Mobile Safari that user action is required
     * to continue playing / loading the audio file.
     */</span>

    <b>this</b>._onsuspend = <b>function </b>() {

      <b>if </b>(_t._iO.onsuspend) {
        _s._wD('SMSound._onsuspend()');
        _t._iO.onsuspend.apply(_t);
      }

      <b>return</b> <b>true</b>;

    };

<span class="multiComment">    /**
     * flash 9/movieStar + RTMP-only method, should fire only once at most
     * at this point we just recreate failed sounds rather than trying to reconnect
     */</span>

    <b>this</b>._onfailure = <b>function </b>(msg, level, code) {

      _t.failures++;
      _s._wD('SMSound._onfailure(): "'+_t.sID+'" count '+_t.failures);

      <b>if </b>(_t._iO.onfailure && _t.failures === 1) {
        _t._iO.onfailure(_t, msg, level, code);
      } <b>else </b>{
        _s._wD('SMSound._onfailure(): ignoring');
      }

    };

    <b>this</b>._onfinish = <b>function </b>() {

<span class="singleComment">      // store local copy before it gets trashed..</span>
      <b>var </b>_io_onfinish = _t._iO.onfinish;

      _t._onbufferchange(0);
      _t._resetOnPosition(0);

<span class="singleComment">      // reset some state items</span>
      <b>if </b>(_t.instanceCount) {

        _t.instanceCount--;

        <b>if </b>(!_t.instanceCount) {

<span class="singleComment">          // remove onPosition listeners, if any</span>
          _detachOnPosition();

<span class="singleComment">          // reset instance options</span>
          _t.playState = 0;
          _t.paused = <b>false</b>;
          _t.instanceCount = 0;
          _t.instanceOptions = {};
          _t._iO = {};
          _stop_html5_timer();

        }

        <b>if </b>(!_t.instanceCount || _t._iO.multiShotEvents) {
<span class="singleComment">          // fire onfinish for last, or every instance</span>
          <b>if </b>(_io_onfinish) {
            _s._wD('SMSound._onfinish(): "' + _t.sID + '"');
            _io_onfinish.apply(_t);
          }
        }

      }

    };

    <b>this</b>._whileloading = <b>function </b>(nBytesLoaded, nBytesTotal, nDuration, nBufferLength) {

      <b>var </b>_iO = _t._iO;

      _t.bytesLoaded = nBytesLoaded;
      _t.bytesTotal = nBytesTotal;
      _t.duration = Math.floor(nDuration);
      _t.bufferLength = nBufferLength;

      <b>if </b>(!_iO.isMovieStar) {

        <b>if </b>(_iO.duration) {
<span class="singleComment">          // use options, if specified and larger</span>
          _t.durationEstimate = (_t.duration &gt; _iO.duration) ? _t.duration : _iO.duration;
        } <b>else </b>{
          _t.durationEstimate = parseInt((_t.bytesTotal / _t.bytesLoaded) * _t.duration, 10);

        }

        <b>if </b>(_t.durationEstimate === undefined) {
          _t.durationEstimate = _t.duration;
        }

        <b>if </b>(_t.readyState !== 3 && _iO.whileloading) {
          _iO.whileloading.apply(_t);
        }

      } <b>else </b>{

        _t.durationEstimate = _t.duration;
        <b>if </b>(_t.readyState !== 3 && _iO.whileloading) {
          _iO.whileloading.apply(_t);
        }

      }

    };

    <b>this</b>._whileplaying = <b>function </b>(nPosition, oPeakData, oWaveformDataLeft, oWaveformDataRight, oEQData) {

      <b>var </b>_iO = _t._iO,
          eqLeft;

      <b>if </b>(isNaN(nPosition) || nPosition === <b>null</b>) {
<span class="singleComment">        // flash safety net</span>
        <b>return</b> <b>false</b>;
      }

      _t.position = nPosition;
      _t._processOnPosition();

      <b>if </b>(!_t.isHTML5 && _fV &gt; 8) {

        <b>if </b>(_iO.usePeakData && <b>typeof </b>oPeakData !== 'undefined' && oPeakData) {
          _t.peakData = {
            left: oPeakData.leftPeak,
            right: oPeakData.rightPeak
          };
        }

        <b>if </b>(_iO.useWaveformData && <b>typeof </b>oWaveformDataLeft !== 'undefined' && oWaveformDataLeft) {
          _t.waveformData = {
            left: oWaveformDataLeft.split(','),
            right: oWaveformDataRight.split(',')
          };
        }

        <b>if </b>(_iO.useEQData) {
          <b>if </b>(<b>typeof </b>oEQData !== 'undefined' && oEQData && oEQData.leftEQ) {
            eqLeft = oEQData.leftEQ.split(',');
            _t.eqData = eqLeft;
            _t.eqData.left = eqLeft;
            <b>if </b>(<b>typeof </b>oEQData.rightEQ !== 'undefined' && oEQData.rightEQ) {
              _t.eqData.right = oEQData.rightEQ.split(',');
            }
          }
        }

      }

      <b>if </b>(_t.playState === 1) {

<span class="singleComment">        // special case/hack: ensure buffering is false if loading from cache (and not yet started)</span>
        <b>if </b>(!_t.isHTML5 && _fV === 8 && !_t.position && _t.isBuffering) {
          _t._onbufferchange(0);
        }

        <b>if </b>(_iO.whileplaying) {
<span class="singleComment">          // flash may call after actual finish</span>
          _iO.whileplaying.apply(_t);
        }

      }

      <b>return</b> <b>true</b>;

    };

    <b>this</b>._onmetadata = <b>function </b>(oMDProps, oMDData) {

<span class="multiComment">      /**
       * internal: flash 9 + NetStream (MovieStar/RTMP-only) feature
       * RTMP may include song title, MovieStar content may include encoding info
       * 
       * @param {array} oMDProps (names)
       * @param {array} oMDData (values)
       */</span>

      _s._wD('SMSound._onmetadata(): "' + <b>this</b>.sID + '" metadata received.');

      <b>var </b>oData = {}, i, j;

      <b>for </b>(i = 0, j = oMDProps.length; i &lt; j; i++) {
        oData[oMDProps[i]] = oMDData[i];
      }
      _t.metadata = oData;

      <b>if </b>(_t._iO.onmetadata) {
        _t._iO.onmetadata.apply(_t);
      }

    };

    <b>this</b>._onid3 = <b>function </b>(oID3Props, oID3Data) {

<span class="multiComment">      /**
       * internal: flash 8 + flash 9 ID3 feature
       * may include artist, song title etc.
       * 
       * @param {array} oID3Props (names)
       * @param {array} oID3Data (values)
       */</span>

      _s._wD('SMSound._onid3(): "' + <b>this</b>.sID + '" ID3 data received.');

      <b>var </b>oData = [], i, j;

      <b>for </b>(i = 0, j = oID3Props.length; i &lt; j; i++) {
        oData[oID3Props[i]] = oID3Data[i];
      }
      _t.id3 = _mixin(_t.id3, oData);

      <b>if </b>(_t._iO.onid3) {
        _t._iO.onid3.apply(_t);
      }

    };

<span class="singleComment">    // flash/RTMP-only</span>

    <b>this</b>._onconnect = <b>function </b>(bSuccess) {

      bSuccess = (bSuccess === 1);
      _s._wD('SMSound._onconnect(): "'+_t.sID+'"'+(bSuccess?' connected.':' failed to connect? - '+_t.url), (bSuccess?1:2));
      _t.connected = bSuccess;

      <b>if </b>(bSuccess) {

        _t.failures = 0;

        <b>if </b>(_idCheck(_t.sID)) {
          <b>if </b>(_t.getAutoPlay()) {
<span class="singleComment">            // only update the play state if auto playing</span>
            _t.play(undefined, _t.getAutoPlay());
          } <b>else </b><b>if </b>(_t._iO.autoLoad) {
            _t.load();
          }
        }

        <b>if </b>(_t._iO.onconnect) {
          _t._iO.onconnect.apply(_t, [bSuccess]);
        }

      }

    };

    <b>this</b>._ondataerror = <b>function </b>(sError) {

<span class="singleComment">      // flash 9 wave/eq data handler</span>
<span class="singleComment">      // hack: called at start, and end from flash at/after onfinish()</span>
      <b>if </b>(_t.playState &gt; 0) {
        _s._wD('SMSound._ondataerror(): ' + sError);
        <b>if </b>(_t._iO.ondataerror) {
          _t._iO.ondataerror.apply(_t);
        }
      }

    };

  }; // SMSound()

<span class="multiComment">  /**
   * Private SoundManager internals
   * ------------------------------
   */</span>

  _getDocument = <b>function </b>() {

    <b>return</b> (_doc.body || _doc._docElement || _doc.getElementsByTagName('div')[0]);

  };

  _id = <b>function </b>(sID) {

    <b>return</b> _doc.getElementById(sID);

  };

  _mixin = <b>function </b>(oMain, oAdd) {

<span class="singleComment">    // non-destructive merge</span>
    <b>var </b>o1 = {}, i, o2, o;

<span class="singleComment">    // clone c1</span>
    <b>for </b>(i<b> in </b>oMain) {
      <b>if </b>(oMain.hasOwnProperty(i)) {
        o1[i] = oMain[i];
      }
    }

    o2 = (<b>typeof </b>oAdd === 'undefined'?_s.defaultOptions:oAdd);
    <b>for </b>(o<b> in </b>o2) {
      <b>if </b>(o2.hasOwnProperty(o) && <b>typeof </b>o1[o] === 'undefined') {
        o1[o] = o2[o];
      }
    }
    <b>return</b> o1;

  };

  _event = (<b>function </b>() {

    <b>var </b>old = (_win.attachEvent),
    evt = {
      add: (old?'attachEvent':'addEventListener'),
      remove: (old?'detachEvent':'removeEventListener')
    };

    function getArgs(oArgs) {

      <b>var </b>args = _slice.call(oArgs), len = args.length;

      <b>if </b>(old) {
<span class="singleComment">        // prefix</span>
        args[1] = 'on' + args[1];
        <b>if </b>(len &gt; 3) {
<span class="singleComment">          // no capture</span>
          args.pop();
        }
      } <b>else </b><b>if </b>(len === 3) {
        args.push(<b>false</b>);
      }

      <b>return</b> args;

    }

    function apply(args, sType) {

      <b>var </b>element = args.shift(),
          method = [evt[sType]];

      <b>if </b>(old) {
        element[method](args[0], args[1]);
      } <b>else </b>{
        element[method].apply(element, args);
      }

    }

    function add() {

      apply(getArgs(arguments), 'add');

    }

    function remove() {

      apply(getArgs(arguments), 'remove');

    }

    <b>return</b> {
      'add': add,
      'remove': remove
    };

  }());

<span class="multiComment">  /**
   * Internal HTML5 event handling
   * -----------------------------
   */</span>

  function _html5_event(oFn) {

<span class="singleComment">    // wrap html5 event handlers so we don't call them on destroyed sounds</span>

    <b>return</b> <b>function </b>(e) {

      <b>var </b>t = <b>this</b>._t;

      <b>if </b>(!t || !t._a) {
<span class="singleComment">        // &lt;d&gt;</span>
        <b>if </b>(t && t.sID) {
          _s._wD(_h5+'ignoring '+e.type+': '+t.sID);
        } <b>else </b>{
          _s._wD(_h5+'ignoring '+e.type);
        }
<span class="singleComment">        // &lt;/d&gt;</span>
        <b>return</b> <b>null</b>;
      } <b>else </b>{
        <b>return</b> oFn.call(<b>this</b>, e);
      }

    };

  }

  _html5_events = {

<span class="singleComment">    // HTML5 event-name-to-handler map</span>

    abort: _html5_event(<b>function </b>() {

      _s._wD(_h5+'abort: '+<b>this</b>._t.sID);

    }),

<span class="singleComment">    // enough has loaded to play</span>

    canplay: _html5_event(<b>function </b>() {

      <b>var </b>t = <b>this</b>._t,
          position1K;

      <b>if </b>(t._html5_canplay) {
<span class="singleComment">        // this event has already fired. ignore.</span>
        <b>return</b> <b>true</b>;
      }

      t._html5_canplay = <b>true</b>;
      _s._wD(_h5+'canplay: '+t.sID+', '+t.url);
      t._onbufferchange(0);
      position1K = (!isNaN(t.position)?t.position/1000:<b>null</b>);

<span class="singleComment">      // set the position if position was set before the sound loaded</span>
      <b>if </b>(t.position && <b>this</b>.currentTime !== position1K) {
        _s._wD(_h5+'canplay: setting position to '+position1K);
        <b>try </b>{
          <b>this</b>.currentTime = position1K;
        } <b>catch </b>(ee) {
          _s._wD(_h5+'setting position failed: '+ee.message, 2);
        }
      }

<span class="singleComment">      // hack for HTML5 from/to case</span>
      <b>if </b>(t._iO._oncanplay) {
        t._iO._oncanplay();
      }

    }),

    load: _html5_event(<b>function </b>() {

      <b>var </b>t = <b>this</b>._t;

      <b>if </b>(!t.loaded) {
        t._onbufferchange(0);
<span class="singleComment">        // should be 1, and the same</span>
        t._whileloading(t.bytesTotal, t.bytesTotal, t._get_html5_duration());
        t._onload(<b>true</b>);
      }

    }),

<span class="singleComment">    // TODO: Reserved for potential use</span>
<span class="multiComment">    /*
    emptied: _html5_event(<b>function </b>() {

      _s._wD(_h5+'emptied: '+<b>this</b>._t.sID);

    }),
    */</span>

    ended: _html5_event(<b>function </b>() {

      <b>var </b>t = <b>this</b>._t;

      _s._wD(_h5+'ended: '+t.sID);
      t._onfinish();

    }),

    error: _html5_event(<b>function </b>() {

      _s._wD(_h5+'error: '+<b>this</b>.error.code);
<span class="singleComment">      // call load with error state?</span>
      <b>this</b>._t._onload(<b>false</b>);

    }),

    loadeddata: _html5_event(<b>function </b>() {

      <b>var </b>t = <b>this</b>._t,
<span class="singleComment">          // at least 1 byte, so math works</span>
          bytesTotal = t.bytesTotal || 1;

      _s._wD(_h5+'loadeddata: '+<b>this</b>._t.sID);

<span class="singleComment">      // safari seems to nicely report progress events, eventually totalling 100%</span>
      <b>if </b>(!t._loaded && !_isSafari) {
        t.duration = t._get_html5_duration();
<span class="singleComment">        // fire whileloading() with 100% values</span>
        t._whileloading(bytesTotal, bytesTotal, t._get_html5_duration());
        t._onload(<b>true</b>);
      }

    }),

    loadedmetadata: _html5_event(<b>function </b>() {

      _s._wD(_h5+'loadedmetadata: '+<b>this</b>._t.sID);

    }),

    loadstart: _html5_event(<b>function </b>() {

      _s._wD(_h5+'loadstart: '+<b>this</b>._t.sID);
<span class="singleComment">      // assume buffering at first</span>
      <b>this</b>._t._onbufferchange(1);

    }),

    play: _html5_event(<b>function </b>() {

      _s._wD(_h5+'play: '+<b>this</b>._t.sID+', '+<b>this</b>._t.url);
<span class="singleComment">      // once play starts, no buffering</span>
      <b>this</b>._t._onbufferchange(0);

    }),

    playing: _html5_event(<b>function </b>() {

      _s._wD(_h5+'playing: '+<b>this</b>._t.sID);

<span class="singleComment">      // once play starts, no buffering</span>
      <b>this</b>._t._onbufferchange(0);

    }),

    progress: _html5_event(<b>function </b>(e) {

      <b>var </b>t = <b>this</b>._t,
          i, j, str, buffered = 0,
          isProgress = (e.type === 'progress'),
          ranges = e.target.buffered,
<span class="singleComment">          // firefox 3.6 implements e.loaded/total (bytes)</span>
          loaded = (e.loaded||0),
          total = (e.total||1);

      <b>if </b>(t.loaded) {
        <b>return</b> <b>false</b>;
      }

      <b>if </b>(ranges && ranges.length) {

<span class="singleComment">        // if loaded is 0, try TimeRanges implementation as % of load</span>
<span class="singleComment">        // https://developer.mozilla.org/en/DOM/TimeRanges</span>

        <b>for </b>(i=ranges.length-1; i &gt;= 0; i--) {
          buffered = (ranges.end(i) - ranges.start(i));
        }

<span class="singleComment">        // linear case, buffer sum; does not account for seeking and HTTP partials / byte ranges</span>
        loaded = buffered/e.target.duration;

<span class="singleComment">        // &lt;d&gt;</span>
        <b>if </b>(isProgress && ranges.length &gt; 1) {
          str = [];
          j = ranges.length;
          <b>for </b>(i=0; i&lt;j; i++) {
            str.push(e.target.buffered.start(i) +'-'+ e.target.buffered.end(i));
          }
          _s._wD(_h5+'progress: timeRanges: '+str.join(', '));
        }

        <b>if </b>(isProgress && !isNaN(loaded)) {
          _s._wD(_h5+'progress: '+t.sID+': ' + Math.floor(loaded*100)+'% loaded');
        }
<span class="singleComment">        // &lt;/d&gt;</span>

      }

      <b>if </b>(!isNaN(loaded)) {

<span class="singleComment">        // if progress, likely not buffering</span>
        t._onbufferchange(0);
        t._whileloading(loaded, total, t._get_html5_duration());
        <b>if </b>(loaded && total && loaded === total) {
<span class="singleComment">          // in case "onload" doesn't fire (eg. gecko 1.9.2)</span>
          _html5_events.load.call(<b>this</b>, e);
        }

      }

    }),

    ratechange: _html5_event(<b>function </b>() {

      _s._wD(_h5+'ratechange: '+<b>this</b>._t.sID);

    }),

    suspend: _html5_event(<b>function </b>(e) {

<span class="singleComment">      // download paused/stopped, may have finished (eg. onload)</span>
      <b>var </b>t = <b>this</b>._t;

      _s._wD(_h5+'suspend: '+t.sID);
      _html5_events.progress.call(<b>this</b>, e);
      t._onsuspend();

    }),

    stalled: _html5_event(<b>function </b>() {

      _s._wD(_h5+'stalled: '+<b>this</b>._t.sID);

    }),

    timeupdate: _html5_event(<b>function </b>() {

      <b>this</b>._t._onTimer();

    }),

    waiting: _html5_event(<b>function </b>() {

      <b>var </b>t = <b>this</b>._t;

<span class="singleComment">      // see also: seeking</span>
      _s._wD(_h5+'waiting: '+t.sID);

<span class="singleComment">      // playback faster than download rate, etc.</span>
      t._onbufferchange(1);

    })

  };

  _html5OK = <b>function </b>(iO) {

<span class="singleComment">    // Use type, if specified. If HTML5-only mode, no other options, so just give 'er</span>
    <b>return</b> (!iO.serverURL && (iO.type?_html5CanPlay({type:iO.type}):_html5CanPlay({url:iO.url})||_s.html5Only));

  };

  _html5Unload = <b>function </b>(oAudio) {

<span class="multiComment">    /**
     * Internal method: Unload media, and cancel any current/pending network requests.
     * Firefox can load an empty URL, which allegedly destroys the decoder and stops the download.
     * https://developer.mozilla.org/En/Using_audio_and_video_in_Firefox#Stopping_the_download_of_media
     * Other UA behaviour is unclear, so everyone else gets an about:blank-style URL.
     */</span>

    <b>if </b>(oAudio) {
<span class="singleComment">      // Firefox likes '' for unload, most other UAs don't and fail to unload.</span>
      oAudio.src = (_is_firefox ? '' : _emptyURL);
    }

  };

  _html5CanPlay = <b>function </b>(o) {

<span class="multiComment">    /**
     * Try to find MIME, test and return truthiness
     * o = {
     *  url: '/path/to/an.mp3',
     *  type: 'audio/mp3'
     * }
     */</span>

    <b>if </b>(!_s.useHTML5Audio || !_s.hasHTML5) {
      <b>return</b> <b>false</b>;
    }

    <b>var </b>url = (o.url || <b>null</b>),
        mime = (o.type || <b>null</b>),
        aF = _s.audioFormats,
        result,
        offset,
        fileExt,
        item;

    function preferFlashCheck(kind) {

<span class="singleComment">      // whether flash should play a given type</span>
      <b>return</b> (_s.preferFlash && _hasFlash && !_s.ignoreFlash && (<b>typeof </b>_s.flash[kind] !== 'undefined' && _s.flash[kind]));

    }

<span class="singleComment">    // account for known cases like audio/mp3</span>

    <b>if </b>(mime && <b>typeof </b>_s.html5[mime] !== 'undefined') {
      <b>return</b> (_s.html5[mime] && !preferFlashCheck(mime));
    }

    <b>if </b>(!_html5Ext) {
      _html5Ext = [];
      <b>for </b>(item<b> in </b>aF) {
        <b>if </b>(aF.hasOwnProperty(item)) {
          _html5Ext.push(item);
          <b>if </b>(aF[item].related) {
            _html5Ext = _html5Ext.concat(aF[item].related);
          }
        }
      }
      _html5Ext = <b>new </b>RegExp('\\.('+_html5Ext.join('|')+')(\\?.*)?$','i');
    }

<span class="singleComment">    // TODO: Strip URL queries, etc.</span>
    fileExt = (url ? url.toLowerCase().match(_html5Ext) : <b>null</b>);

    <b>if </b>(!fileExt || !fileExt.length) {
      <b>if </b>(!mime) {
        <b>return</b> <b>false</b>;
      } <b>else </b>{
<span class="singleComment">        // audio/mp3 -&gt; mp3, result should be known</span>
        offset = mime.indexOf(';');
<span class="singleComment">        // strip "audio/X; codecs.."</span>
        fileExt = (offset !== -1?mime.substr(0,offset):mime).substr(6);
      }
    } <b>else </b>{
<span class="singleComment">      // match the raw extension name - "mp3", for example</span>
      fileExt = fileExt[1];
    }

    <b>if </b>(fileExt && <b>typeof </b>_s.html5[fileExt] !== 'undefined') {
<span class="singleComment">      // result known</span>
      <b>return</b> (_s.html5[fileExt] && !preferFlashCheck(fileExt));
    } <b>else </b>{
      mime = 'audio/'+fileExt;
      result = _s.html5.canPlayType({type:mime});
      _s.html5[fileExt] = result;
<span class="singleComment">      // _s._wD('canPlayType, found result: '+result);</span>
      <b>return</b> (result && _s.html5[mime] && !preferFlashCheck(mime));
    }

  };

  _testHTML5 = <b>function </b>() {

    <b>if </b>(!_s.useHTML5Audio || <b>typeof </b>Audio === 'undefined') {
      <b>return</b> <b>false</b>;
    }

<span class="singleComment">    // double-whammy: Opera 9.64 throws WRONG_ARGUMENTS_ERR if no parameter passed to Audio(), and Webkit + iOS happily tries to load "null" as a URL. :/</span>
    <b>var </b>a = (<b>typeof </b>Audio !== 'undefined' ? (_isOpera ? <b>new </b>Audio(<b>null</b>) : <b>new </b>Audio()) : <b>null</b>),
        item, support = {}, aF, i;

    function _cp(m) {

      <b>var </b>canPlay, i, j, isOK = <b>false</b>;

      <b>if </b>(!a || <b>typeof </b>a.canPlayType !== 'function') {
        <b>return</b> <b>false</b>;
      }

      <b>if </b>(m<b> instanceof </b>Array) {
<span class="singleComment">        // iterate through all mime types, return any successes</span>
        <b>for </b>(i=0, j=m.length; i&lt;j && !isOK; i++) {
          <b>if </b>(_s.html5[m[i]] || a.canPlayType(m[i]).match(_s.html5Test)) {
            isOK = <b>true</b>;
            _s.html5[m[i]] = <b>true</b>;

<span class="singleComment">            // if flash can play and preferred, also mark it for use.</span>
            _s.flash[m[i]] = !!(_s.preferFlash && _hasFlash && m[i].match(_flashMIME));

          }
        }
        <b>return</b> isOK;
      } <b>else </b>{
        canPlay = (a && <b>typeof </b>a.canPlayType === 'function' ? a.canPlayType(m) : <b>false</b>);
        <b>return</b> !!(canPlay && (canPlay.match(_s.html5Test)));
      }

    }

<span class="singleComment">    // test all registered formats + codecs</span>

    aF = _s.audioFormats;

    <b>for </b>(item<b> in </b>aF) {
      <b>if </b>(aF.hasOwnProperty(item)) {
        support[item] = _cp(aF[item].type);

<span class="singleComment">        // write back generic type too, eg. audio/mp3</span>
        support['audio/'+item] = support[item];

<span class="singleComment">        // assign flash</span>
        <b>if </b>(_s.preferFlash && !_s.ignoreFlash && item.match(_flashMIME)) {
          _s.flash[item] = <b>true</b>;
        } <b>else </b>{
          _s.flash[item] = <b>false</b>;
        }

<span class="singleComment">        // assign result to related formats, too</span>
        <b>if </b>(aF[item] && aF[item].related) {
          <b>for </b>(i=aF[item].related.length-1; i &gt;= 0; i--) {
<span class="singleComment">            // eg. audio/m4a</span>
            support['audio/'+aF[item].related[i]] = support[item];
            _s.html5[aF[item].related[i]] = support[item];
            _s.flash[aF[item].related[i]] = support[item];
          }
        }
      }
    }

    support.canPlayType = (a?_cp:<b>null</b>);
    _s.html5 = _mixin(_s.html5, support);

    <b>return</b> <b>true</b>;

  };

  _strings = {

<span class="singleComment">    // &lt;d&gt;</span>
    notReady: 'Not loaded yet - wait for soundManager.onload()/onready()',
    notOK: 'Audio support is not available.',
    domError: _smc + 'createMovie(): appendChild/innerHTML call failed. DOM not ready or other error.',
    spcWmode: _smc + 'createMovie(): Removing wmode, preventing known SWF loading issue(s)',
    swf404: _sm + ': Verify that %s is a valid path.',
    tryDebug: 'Try ' + _sm + '.debugFlash = <b>true</b> for more security details (output goes to SWF.)',
    checkSWF: 'See SWF output for more debug info.',
    localFail: _sm + ': Non-HTTP page (' + _doc.location.protocol + ' URL?) Review Flash player security settings for <b>this</b> special case:\nhttp://www.macromedia.com/support/documentation/en/flashplayer/help/settings_manager04.html\nMay need to add/allow path, eg. c:/sm2/ or /users/me/sm2/',
    waitFocus: _sm + ': Special case: Waiting for focus-related event..',
    waitImpatient: _sm + ': Getting impatient, still waiting for Flash%s...',
    waitForever: _sm + ': Waiting indefinitely for Flash (will recover if unblocked)...',
    needFunction: _sm + ': Function object expected for %s',
    badID: 'Warning: Sound ID "%s" should be a string, starting with a non-numeric character',
    currentObj: '--- ' + _sm + '._debug(): Current sound objects ---',
    waitEI: _smc + 'initMovie(): Waiting for ExternalInterface call from Flash..',
    waitOnload: _sm + ': Waiting for window.onload()',
    docLoaded: _sm + ': Document already loaded',
    onload: _smc + 'initComplete(): calling soundManager.onload()',
    onloadOK: _sm + '.onload() complete',
    init: _smc + 'init()',
    didInit: _smc + 'init(): Already called?',
    flashJS: _sm + ': Attempting to call Flash from JS..',
    secNote: 'Flash security note: Network/internet URLs will not load due to security restrictions. Access can be configured via Flash Player Global Security Settings Page: http://www.macromedia.com/support/documentation/en/flashplayer/help/settings_manager04.html',
    badRemove: 'Warning: Failed to remove flash movie.',
    noPeak: 'Warning: peakData features unsupported for movieStar formats',
    shutdown: _sm + '.disable(): Shutting down',
    queue: _sm + ': Queueing %s handler',
    smFail: _sm + ': Failed to initialise.',
    smError: 'SMSound.load(): Exception: JS-Flash communication failed, or JS error.',
    fbTimeout: 'No flash response, applying .'+_swfCSS.swfTimedout+' CSS..',
    fbLoaded: 'Flash loaded',
    fbHandler: _smc+'flashBlockHandler()',
    manURL: 'SMSound.load(): Using manually-assigned URL',
    onURL: _sm + '.load(): current URL already assigned.',
    badFV: _sm + '.flashVersion must be 8 or 9. "%s" is invalid. Reverting to %s.',
    as2loop: 'Note: Setting stream:<b>false</b> so looping can work (flash 8 limitation)',
    noNSLoop: 'Note: Looping not implemented for MovieStar formats',
    needfl9: 'Note: Switching to flash 9, required for MP4 formats.',
    mfTimeout: 'Setting flashLoadTimeout = 0 (infinite) for off-screen, mobile flash case',
    mfOn: 'mobileFlash::enabling on-screen flash repositioning',
    policy: 'Enabling usePolicyFile for data access'
<span class="singleComment">    // &lt;/d&gt;</span>

  };

  _str = <b>function </b>() {

<span class="singleComment">    // internal string replace helper.</span>
<span class="singleComment">    // arguments: o [,items to replace]</span>
<span class="singleComment">    // &lt;d&gt;</span>

<span class="singleComment">    // real array, please</span>
    <b>var </b>args = _slice.call(arguments),

<span class="singleComment">    // first arg</span>
    o = args.shift(),

    str = (_strings && _strings[o]?_strings[o]:''), i, j;
    <b>if </b>(str && args && args.length) {
      <b>for </b>(i = 0, j = args.length; i &lt; j; i++) {
        str = str.replace('%s', args[i]);
      }
    }

    <b>return</b> str;
<span class="singleComment">    // &lt;/d&gt;</span>

  };

  _loopFix = <b>function </b>(sOpt) {

<span class="singleComment">    // flash 8 requires stream = false for looping to work</span>
    <b>if </b>(_fV === 8 && sOpt.loops &gt; 1 && sOpt.stream) {
      _wDS('as2loop');
      sOpt.stream = <b>false</b>;
    }

    <b>return</b> sOpt;

  };

  _policyFix = <b>function </b>(sOpt, sPre) {

    <b>if </b>(sOpt && !sOpt.usePolicyFile && (sOpt.onid3 || sOpt.usePeakData || sOpt.useWaveformData || sOpt.useEQData)) {
      _s._wD((sPre || '') + _str('policy'));
      sOpt.usePolicyFile = <b>true</b>;
    }

    <b>return</b> sOpt;

  };

  _complain = <b>function </b>(sMsg) {

<span class="singleComment">    // &lt;d&gt;</span>
    <b>if </b>(<b>typeof </b>console !== 'undefined' && <b>typeof </b>console.warn !== 'undefined') {
      console.warn(sMsg);
    } <b>else </b>{
      _s._wD(sMsg);
    }
<span class="singleComment">    // &lt;/d&gt;</span>

  };

  _doNothing = <b>function </b>() {

    <b>return</b> <b>false</b>;

  };

  _disableObject = <b>function </b>(o) {

    <b>var </b>oProp;

    <b>for </b>(oProp<b> in </b>o) {
      <b>if </b>(o.hasOwnProperty(oProp) && <b>typeof </b>o[oProp] === 'function') {
        o[oProp] = _doNothing;
      }
    }

    oProp = <b>null</b>;

  };

  _failSafely = <b>function </b>(bNoDisable) {

<span class="singleComment">    // general failure exception handler</span>

    <b>if </b>(<b>typeof </b>bNoDisable === 'undefined') {
      bNoDisable = <b>false</b>;
    }

    <b>if </b>(_disabled || bNoDisable) {
      _wDS('smFail', 2);
      _s.disable(bNoDisable);
    }

  };

  _normalizeMovieURL = <b>function </b>(smURL) {

    <b>var </b>urlParams = <b>null</b>, url;

    <b>if </b>(smURL) {
      <b>if </b>(smURL.match(/\.swf(\?.*)?$/i)) {
        urlParams = smURL.substr(smURL.toLowerCase().lastIndexOf('.swf?') + 4);
        <b>if </b>(urlParams) {
<span class="singleComment">          // assume user knows what they're doing</span>
          <b>return</b> smURL;
        }
      } <b>else </b><b>if </b>(smURL.lastIndexOf('/') !== smURL.length - 1) {
<span class="singleComment">        // append trailing slash, if needed</span>
        smURL += '/';
      }
    }

    url = (smURL && smURL.lastIndexOf('/') !== - 1 ? smURL.substr(0, smURL.lastIndexOf('/') + 1) : './') + _s.movieURL;

    <b>if </b>(_s.noSWFCache) {
      url += ('?ts=' + <b>new </b>Date().getTime());
    }

    <b>return</b> url;

  };

  _setVersionInfo = <b>function </b>() {

<span class="singleComment">    // short-hand for internal use</span>

    _fV = parseInt(_s.flashVersion, 10);

    <b>if </b>(_fV !== 8 && _fV !== 9) {
      _s._wD(_str('badFV', _fV, _defaultFlashVersion));
      _s.flashVersion = _fV = _defaultFlashVersion;
    }

<span class="singleComment">    // debug flash movie, if applicable</span>

    <b>var </b>isDebug = (_s.debugMode || _s.debugFlash?'_debug.swf':'.swf');

    <b>if </b>(_s.useHTML5Audio && !_s.html5Only && _s.audioFormats.mp4.required && _fV &lt; 9) {
      _s._wD(_str('needfl9'));
      _s.flashVersion = _fV = 9;
    }

    _s.version = _s.versionNumber + (_s.html5Only?' (HTML5-only mode)':(_fV === 9?' (AS3/Flash 9)':' (AS2/Flash 8)'));

<span class="singleComment">    // set up default options</span>
    <b>if </b>(_fV &gt; 8) {
<span class="singleComment">      // +flash 9 base options</span>
      _s.defaultOptions = _mixin(_s.defaultOptions, _s.flash9Options);
      _s.features.buffering = <b>true</b>;
<span class="singleComment">      // +moviestar support</span>
      _s.defaultOptions = _mixin(_s.defaultOptions, _s.movieStarOptions);
      _s.filePatterns.flash9 = <b>new </b>RegExp('\\.(mp3|' + _netStreamTypes.join('|') + ')(\\?.*)?$', 'i');
      _s.features.movieStar = <b>true</b>;
    } <b>else </b>{
      _s.features.movieStar = <b>false</b>;
    }

<span class="singleComment">    // regExp for flash canPlay(), etc.</span>
    _s.filePattern = _s.filePatterns[(_fV !== 8?'flash9':'flash8')];

<span class="singleComment">    // if applicable, use _debug versions of SWFs</span>
    _s.movieURL = (_fV === 8?'soundmanager2.swf':'soundmanager2_flash9.swf').replace('.swf', isDebug);

    _s.features.peakData = _s.features.waveformData = _s.features.eqData = (_fV &gt; 8);

  };

  _setPolling = <b>function </b>(bPolling, bHighPerformance) {

    <b>if </b>(!_flash) {
      <b>return</b> <b>false</b>;
    }

    _flash._setPolling(bPolling, bHighPerformance);

  };

  _initDebug = <b>function </b>() {

<span class="singleComment">    // starts debug mode, creating output &lt;div&gt; for UAs without console object</span>

<span class="singleComment">    // allow force of debug mode via URL</span>
    <b>if </b>(_s.debugURLParam.test(_wl)) {
      _s.debugMode = <b>true</b>;
    }

<span class="singleComment">    // &lt;d&gt;</span>
    <b>if </b>(_id(_s.debugID)) {
      <b>return</b> <b>false</b>;
    }

    <b>var </b>oD, oDebug, oTarget, oToggle, tmp;

    <b>if </b>(_s.debugMode && !_id(_s.debugID) && (!_hasConsole || !_s.useConsole || !_s.consoleOnly)) {

      oD = _doc.createElement('div');
      oD.id = _s.debugID + '-toggle';

      oToggle = {
        'position': 'fixed',
        'bottom': '0px',
        'right': '0px',
        'width': '1.2em',
        'height': '1.2em',
        'lineHeight': '1.2em',
        'margin': '2px',
        'textAlign': 'center',
        'border': '1px solid #999',
        'cursor': 'pointer',
        'background': '#fff',
        'color': '#333',
        'zIndex': 10001
      };

      oD.appendChild(_doc.createTextNode('-'));
      oD.onclick = _toggleDebug;
      oD.title = 'Toggle SM2 debug console';

      <b>if </b>(_ua.match(/msie 6/i)) {
        oD.style.position = 'absolute';
        oD.style.cursor = 'hand';
      }

      <b>for </b>(tmp<b> in </b>oToggle) {
        <b>if </b>(oToggle.hasOwnProperty(tmp)) {
          oD.style[tmp] = oToggle[tmp];
        }
      }

      oDebug = _doc.createElement('div');
      oDebug.id = _s.debugID;
      oDebug.style.display = (_s.debugMode?'block':'none');

      <b>if </b>(_s.debugMode && !_id(oD.id)) {
        <b>try </b>{
          oTarget = _getDocument();
          oTarget.appendChild(oD);
        } <b>catch </b>(e2) {
          <b>throw </b><b>new </b>Error(_str('domError')+' \n'+e2.toString());
        }
        oTarget.appendChild(oDebug);
      }

    }

    oTarget = <b>null</b>;
<span class="singleComment">    // &lt;/d&gt;</span>

  };

  _idCheck = <b>this</b>.getSoundById;

<span class="singleComment">  // &lt;d&gt;</span>
  _wDS = <b>function </b>(o, errorLevel) {

    <b>if </b>(!o) {
      <b>return</b> '';
    } <b>else </b>{
      <b>return</b> _s._wD(_str(o), errorLevel);
    }

  };

<span class="singleComment">  // last-resort debugging option</span>

  <b>if </b>(_wl.indexOf('sm2-debug=alert') + 1 && _s.debugMode) {
    _s._wD = <b>function </b>(sText) {window.alert(sText);};
  }

  _toggleDebug = <b>function </b>() {

    <b>var </b>o = _id(_s.debugID),
    oT = _id(_s.debugID + '-toggle');

    <b>if </b>(!o) {
      <b>return</b> <b>false</b>;
    }

    <b>if </b>(_debugOpen) {
<span class="singleComment">      // minimize</span>
      oT.innerHTML = '+';
      o.style.display = 'none';
    } <b>else </b>{
      oT.innerHTML = '-';
      o.style.display = 'block';
    }

    _debugOpen = !_debugOpen;

  };

  _debugTS = <b>function </b>(sEventType, bSuccess, sMessage) {

<span class="singleComment">    // troubleshooter debug hooks</span>

    <b>if </b>(<b>typeof </b>sm2Debugger !== 'undefined') {
      <b>try </b>{
        sm2Debugger.handleEvent(sEventType, bSuccess, sMessage);
      } <b>catch </b>(e) {
<span class="singleComment">        // oh well</span>
      }
    }

    <b>return</b> <b>true</b>;

  };
<span class="singleComment">  // &lt;/d&gt;</span>

  _getSWFCSS = <b>function </b>() {

    <b>var </b>css = [];

    <b>if </b>(_s.debugMode) {
      css.push(_swfCSS.sm2Debug);
    }

    <b>if </b>(_s.debugFlash) {
      css.push(_swfCSS.flashDebug);
    }

    <b>if </b>(_s.useHighPerformance) {
      css.push(_swfCSS.highPerf);
    }

    <b>return</b> css.join(' ');

  };

  _flashBlockHandler = <b>function </b>() {

<span class="singleComment">    // *possible* flash block situation.</span>

    <b>var </b>name = _str('fbHandler'),
        p = _s.getMoviePercent(),
        css = _swfCSS,
        error = {type:'FLASHBLOCK'};

    <b>if </b>(_s.html5Only) {
      <b>return</b> <b>false</b>;
    }

    <b>if </b>(!_s.ok()) {

      <b>if </b>(_needsFlash) {
<span class="singleComment">        // make the movie more visible, so user can fix</span>
        _s.oMC.className = _getSWFCSS() + ' ' + css.swfDefault + ' ' + (p === <b>null</b>?css.swfTimedout:css.swfError);
        _s._wD(name+': '+_str('fbTimeout')+(p?' ('+_str('fbLoaded')+')':''));
      }

      _s.didFlashBlock = <b>true</b>;

<span class="singleComment">      // fire onready(), complain lightly</span>
      _processOnEvents({type:'ontimeout', ignoreInit:<b>true</b>, error:error});
      _catchError(error);

    } <b>else </b>{

<span class="singleComment">      // SM2 loaded OK (or recovered)</span>

<span class="singleComment">      // &lt;d&gt;</span>
      <b>if </b>(_s.didFlashBlock) {
        _s._wD(name+': Unblocked');
      }
<span class="singleComment">      // &lt;/d&gt;</span>

      <b>if </b>(_s.oMC) {
        _s.oMC.className = [_getSWFCSS(), css.swfDefault, css.swfLoaded + (_s.didFlashBlock?' '+css.swfUnblocked:'')].join(' ');
      }

    }

  };

  _addOnEvent = <b>function </b>(sType, oMethod, oScope) {

    <b>if </b>(<b>typeof </b>_on_queue[sType] === 'undefined') {
      _on_queue[sType] = [];
    }

    _on_queue[sType].push({
      'method': oMethod,
      'scope': (oScope || <b>null</b>),
      'fired': <b>false</b>
    });

  };

  _processOnEvents = <b>function </b>(oOptions) {

<span class="singleComment">    // assume onready, if unspecified</span>

    <b>if </b>(!oOptions) {
      oOptions = {
        type: 'onready'
      };
    }

    <b>if </b>(!_didInit && oOptions && !oOptions.ignoreInit) {
<span class="singleComment">      // not ready yet.</span>
      <b>return</b> <b>false</b>;
    }

    <b>if </b>(oOptions.type === 'ontimeout' && _s.ok()) {
<span class="singleComment">      // invalid case</span>
      <b>return</b> <b>false</b>;
    }

    <b>var </b>status = {
          success: (oOptions && oOptions.ignoreInit?_s.ok():!_disabled)
        },

<span class="singleComment">        // queue specified by type, or none</span>
        srcQueue = (oOptions && oOptions.type?_on_queue[oOptions.type]||[]:[]),

        queue = [], i, j,
        args = [status],
        canRetry = (_needsFlash && _s.useFlashBlock && !_s.ok());

    <b>if </b>(oOptions.error) {
      args[0].error = oOptions.error;
    }

    <b>for </b>(i = 0, j = srcQueue.length; i &lt; j; i++) {
      <b>if </b>(srcQueue[i].fired !== <b>true</b>) {
        queue.push(srcQueue[i]);
      }
    }

    <b>if </b>(queue.length) {
      _s._wD(_sm + ': Firing ' + queue.length + ' '+oOptions.type+'() item' + (queue.length === 1?'':'s'));
      <b>for </b>(i = 0, j = queue.length; i &lt; j; i++) {
        <b>if </b>(queue[i].scope) {
          queue[i].method.apply(queue[i].scope, args);
        } <b>else </b>{
          queue[i].method.apply(<b>this</b>, args);
        }
        <b>if </b>(!canRetry) {
<span class="singleComment">          // flashblock case doesn't count here</span>
          queue[i].fired = <b>true</b>;
        }
      }
    }

    <b>return</b> <b>true</b>;

  };

  _initUserOnload = <b>function </b>() {

    _win.setTimeout(<b>function </b>() {

      <b>if </b>(_s.useFlashBlock) {
        _flashBlockHandler();
      }

      _processOnEvents();

<span class="singleComment">      // call user-defined "onload", scoped to window</span>

      <b>if </b>(_s.onload<b> instanceof </b>Function) {
        _wDS('onload', 1);
        _s.onload.apply(_win);
        _wDS('onloadOK', 1);
      }

      <b>if </b>(_s.waitForWindowLoad) {
        _event.add(_win, 'load', _initUserOnload);
      }

    },1);

  };

  _detectFlash = <b>function </b>() {

<span class="singleComment">    // hat tip: Flash Detect library (BSD, (C) 2007) by Carl "DocYes" S. Yestrau - http://featureblend.com/javascript-flash-detection-library.html / http://featureblend.com/license.txt</span>

    <b>if </b>(_hasFlash !== undefined) {
<span class="singleComment">      // this work has already been done.</span>
      <b>return</b> _hasFlash;
    }

    <b>var </b>hasPlugin = <b>false</b>, n = navigator, nP = n.plugins, obj, type, types, AX = _win.ActiveXObject;

    <b>if </b>(nP && nP.length) {
      type = 'application/x-shockwave-flash';
      types = n.mimeTypes;
      <b>if </b>(types && types[type] && types[type].enabledPlugin && types[type].enabledPlugin.description) {
        hasPlugin = <b>true</b>;
      }
    } <b>else </b><b>if </b>(<b>typeof </b>AX !== 'undefined') {
      <b>try </b>{
        obj = <b>new </b>AX('ShockwaveFlash.ShockwaveFlash');
      } <b>catch </b>(e) {
<span class="singleComment">        // oh well</span>
      }
      hasPlugin = (!!obj);
    }

    _hasFlash = hasPlugin;

    <b>return</b> hasPlugin;

  };

  _featureCheck = <b>function </b>() {

    <b>var </b>needsFlash, item,

<span class="singleComment">        // iPhone &lt;= 3.1 has broken HTML5 audio(), but firmware 3.2 (iPad) + iOS4 works.</span>
        isSpecial = (_is_iDevice && !!(_ua.match(/os (1|2|3_0|3_1)/i)));

    <b>if </b>(isSpecial) {

<span class="singleComment">      // has Audio(), but is broken; let it load links directly.</span>
      _s.hasHTML5 = <b>false</b>;

<span class="singleComment">      // ignore flash case, however</span>
      _s.html5Only = <b>true</b>;

      <b>if </b>(_s.oMC) {
        _s.oMC.style.display = 'none';
      }

      <b>return</b> <b>false</b>;

    }

    <b>if </b>(_s.useHTML5Audio) {

      <b>if </b>(!_s.html5 || !_s.html5.canPlayType) {
        _s._wD('SoundManager: No HTML5 Audio() support detected.');
        _s.hasHTML5 = <b>false</b>;
        <b>return</b> <b>true</b>;
      } <b>else </b>{
        _s.hasHTML5 = <b>true</b>;
      }
      <b>if </b>(_isBadSafari) {
        _s._wD(_smc+'Note: Buggy HTML5 Audio<b> in </b>Safari on <b>this</b> OS X release, see https://bugs.webkit.org/show_bug.cgi?id=32159 - '+(!_hasFlash?' would use flash fallback for MP3/MP4, but none detected.':'will use flash fallback for MP3/MP4, if available'),1);
        <b>if </b>(_detectFlash()) {
          <b>return</b> <b>true</b>;
        }
      }
    } <b>else </b>{

<span class="singleComment">      // flash needed (or, HTML5 needs enabling.)</span>
      <b>return</b> <b>true</b>;

    }

    <b>for </b>(item<b> in </b>_s.audioFormats) {
      <b>if </b>(_s.audioFormats.hasOwnProperty(item)) {
        <b>if </b>((_s.audioFormats[item].required && !_s.html5.canPlayType(_s.audioFormats[item].type)) || _s.flash[item] || _s.flash[_s.audioFormats[item].type]) {
<span class="singleComment">          // flash may be required, or preferred for this format</span>
          needsFlash = <b>true</b>;
        }
      }
    }

<span class="singleComment">    // sanity check..</span>
    <b>if </b>(_s.ignoreFlash) {
      needsFlash = <b>false</b>;
    }

    _s.html5Only = (_s.hasHTML5 && _s.useHTML5Audio && !needsFlash);

    <b>return</b> (!_s.html5Only);

  };

  _parseURL = <b>function </b>(url) {

<span class="multiComment">    /**
     * Internal: Finds and returns the first playable URL (or failing that, the first URL.)
     * @param {string or array} url A single URL string, OR, an array of URL strings or {url:'/path/to/resource', type:'audio/mp3'} objects.
     */</span>

    <b>var </b>i, j, result = 0;

    <b>if </b>(url<b> instanceof </b>Array) {

<span class="singleComment">      // find the first good one</span>
      <b>for </b>(i=0, j=url.length; i&lt;j; i++) {

        <b>if </b>(url[i]<b> instanceof </b>Object) {
<span class="singleComment">          // MIME check</span>
          <b>if </b>(_s.canPlayMIME(url[i].type)) {
            result = i;
            <b>break</b>;
          }

        } <b>else </b><b>if </b>(_s.canPlayURL(url[i])) {
<span class="singleComment">          // URL string check</span>
          result = i;
          <b>break</b>;
        }

      }

<span class="singleComment">      // normalize to string</span>
      <b>if </b>(url[result].url) {
        url[result] = url[result].url;
      }

      <b>return</b> url[result];

    } <b>else </b>{

<span class="singleComment">      // single URL case</span>
      <b>return</b> url;

    }

  };


  _startTimer = <b>function </b>(oSound) {

<span class="multiComment">    /**
     * attach a timer to this sound, and start an interval if needed
     */</span>

    <b>if </b>(!oSound._hasTimer) {

      oSound._hasTimer = <b>true</b>;

      <b>if </b>(!_likesHTML5 && _s.html5PollingInterval) {

        <b>if </b>(_h5IntervalTimer === <b>null</b> && _h5TimerCount === 0) {

          _h5IntervalTimer = window.setInterval(_timerExecute, _s.html5PollingInterval);
   
        }

        _h5TimerCount++;

      }

    }

  };

  _stopTimer = <b>function </b>(oSound) {

<span class="multiComment">    /**
     * detach a timer
     */</span>

    <b>if </b>(oSound._hasTimer) {

      oSound._hasTimer = <b>false</b>;

      <b>if </b>(!_likesHTML5 && _s.html5PollingInterval) {

<span class="singleComment">        // interval will stop itself at next execution.</span>

        _h5TimerCount--;

      }

    }

  };

  _timerExecute = <b>function </b>() {

<span class="multiComment">    /**
     * manual polling for HTML5 progress events, ie., whileplaying() (can achieve greater precision than conservative default HTML5 interval)
     */</span>

    <b>var </b>i;

    <b>if </b>(_h5IntervalTimer !== <b>null</b> && !_h5TimerCount) {

<span class="singleComment">      // no active timers, stop polling interval.</span>

      window.clearInterval(_h5IntervalTimer);

      _h5IntervalTimer = <b>null</b>;

      <b>return</b> <b>false</b>;

    }

<span class="singleComment">    // check all HTML5 sounds with timers</span>

    <b>for </b>(i = _s.soundIDs.length-1; i &gt;= 0; i--) {

      <b>if </b>(_s.sounds[_s.soundIDs[i]].isHTML5 && _s.sounds[_s.soundIDs[i]]._hasTimer) {

        _s.sounds[_s.soundIDs[i]]._onTimer();

      }

    }

  };

  _catchError = <b>function </b>(options) {

    options = (<b>typeof </b>options !== 'undefined' ? options : {});

    <b>if </b>(_s.onerror<b> instanceof </b>Function) {
      _s.onerror.apply(_win, [{type:(<b>typeof </b>options.type !== 'undefined' ? options.type : <b>null</b>)}]);
    }

    <b>if </b>(<b>typeof </b>options.fatal !== 'undefined' && options.fatal) {
      _s.disable();
    }

  };

  _badSafariFix = <b>function </b>() {

<span class="singleComment">    // special case: "bad" Safari (OS X 10.3 - 10.7) must fall back to flash for MP3/MP4</span>
    <b>if </b>(!_isBadSafari || !_detectFlash()) {
<span class="singleComment">      // doesn't apply</span>
      <b>return</b> <b>false</b>;
    }

    <b>var </b>aF = _s.audioFormats, i, item;

    <b>for </b>(item<b> in </b>aF) {
      <b>if </b>(aF.hasOwnProperty(item)) {
        <b>if </b>(item === 'mp3' || item === 'mp4') {
          _s._wD(_sm+': Using flash fallback for '+item+' format');
          _s.html5[item] = <b>false</b>;
<span class="singleComment">          // assign result to related formats, too</span>
          <b>if </b>(aF[item] && aF[item].related) {
            <b>for </b>(i = aF[item].related.length-1; i &gt;= 0; i--) {
              _s.html5[aF[item].related[i]] = <b>false</b>;
            }
          }
        }
      }
    }

  };

<span class="multiComment">  /**
   * Pseudo-private flash/ExternalInterface methods
   * ----------------------------------------------
   */</span>

  <b>this</b>._setSandboxType = <b>function </b>(sandboxType) {

<span class="singleComment">    // &lt;d&gt;</span>
    <b>var </b>sb = _s.sandbox;

    sb.type = sandboxType;
    sb.description = sb.types[(<b>typeof </b>sb.types[sandboxType] !== 'undefined'?sandboxType:'unknown')];

    _s._wD('Flash security sandbox type: ' + sb.type);

    <b>if </b>(sb.type === 'localWithFile') {

      sb.noRemote = <b>true</b>;
      sb.noLocal = <b>false</b>;
      _wDS('secNote', 2);

    } <b>else </b><b>if </b>(sb.type === 'localWithNetwork') {

      sb.noRemote = <b>false</b>;
      sb.noLocal = <b>true</b>;

    } <b>else </b><b>if </b>(sb.type === 'localTrusted') {

      sb.noRemote = <b>false</b>;
      sb.noLocal = <b>false</b>;

    }
<span class="singleComment">    // &lt;/d&gt;</span>

  };

  <b>this</b>._externalInterfaceOK = <b>function </b>(flashDate, swfVersion) {

<span class="singleComment">    // flash callback confirming flash loaded, EI working etc.</span>
<span class="singleComment">    // flashDate = approx. timing/delay info for JS/flash bridge</span>
<span class="singleComment">    // swfVersion: SWF build string</span>

    <b>if </b>(_s.swfLoaded) {
      <b>return</b> <b>false</b>;
    }

    <b>var </b>e, eiTime = <b>new </b>Date().getTime();

    _s._wD(_smc+'externalInterfaceOK()' + (flashDate?' (~' + (eiTime - flashDate) + ' ms)':''));
    _debugTS('swf', <b>true</b>);
    _debugTS('flashtojs', <b>true</b>);
    _s.swfLoaded = <b>true</b>;
    _tryInitOnFocus = <b>false</b>;

    <b>if </b>(_isBadSafari) {
      _badSafariFix();
    }

<span class="singleComment">    // complain if JS + SWF build/version strings don't match, excluding +DEV builds</span>
<span class="singleComment">    // &lt;d&gt;</span>
    <b>if </b>(!swfVersion || swfVersion.replace(/\+dev/i,'') !== _s.versionNumber.replace(/\+dev/i, '')) {

      e = _sm + ': Fatal: JavaScript file build "' + _s.versionNumber + '" does not match Flash SWF build "' + swfVersion + '" at ' + _s.url + '. Ensure both are up-to-date.';

<span class="singleComment">      // escape flash -&gt; JS stack so this error fires in window.</span>
      setTimeout(function versionMismatch() {
        <b>throw </b><b>new </b>Error(e);
      }, 0);

<span class="singleComment">      // exit, init will fail with timeout</span>
      <b>return</b> <b>false</b>;

    }
<span class="singleComment">    // &lt;/d&gt;</span>

    <b>if </b>(_isIE) {
<span class="singleComment">      // IE needs a timeout OR delay until window.onload - may need TODO: investigating</span>
      setTimeout(_init, 100);
    } <b>else </b>{
      _init();
    }

  };

<span class="multiComment">  /**
   * Private initialization helpers
   * ------------------------------
   */</span>

  _createMovie = <b>function </b>(smID, smURL) {

    <b>if </b>(_didAppend && _appendSuccess) {
<span class="singleComment">      // ignore if already succeeded</span>
      <b>return</b> <b>false</b>;
    }

    function _initMsg() {
      _s._wD('-- SoundManager 2 ' + _s.version + (!_s.html5Only && _s.useHTML5Audio?(_s.hasHTML5?' + HTML5 audio':', no HTML5 audio support'):'') + (!_s.html5Only ? (_s.useHighPerformance?', high performance mode, ':', ') + (( _s.flashPollingInterval ? 'custom (' + _s.flashPollingInterval + 'ms)' : 'normal') + ' polling') + (_s.wmode?', wmode: ' + _s.wmode:'') + (_s.debugFlash?', flash debug mode':'') + (_s.useFlashBlock?', flashBlock mode':'') : '') + ' --', 1);
    }

    <b>if </b>(_s.html5Only) {

<span class="singleComment">      // 100% HTML5 mode</span>
      _setVersionInfo();

      _initMsg();
      _s.oMC = _id(_s.movieID);
      _init();

<span class="singleComment">      // prevent multiple init attempts</span>
      _didAppend = <b>true</b>;

      _appendSuccess = <b>true</b>;

      <b>return</b> <b>false</b>;

    }

<span class="singleComment">    // flash path</span>
    <b>var </b>remoteURL = (smURL || _s.url),
    localURL = (_s.altURL || remoteURL),
    swfTitle = 'JS/Flash audio component (SoundManager 2)',
    oEmbed, oMovie, oTarget = _getDocument(), tmp, movieHTML, oEl, extraClass = _getSWFCSS(),
    s, x, sClass, side = <b>null</b>, isRTL = <b>null</b>,
    html = _doc.getElementsByTagName('html')[0];

    isRTL = (html && html.dir && html.dir.match(/rtl/i));
    smID = (<b>typeof </b>smID === 'undefined'?_s.id:smID);

    function param(name, value) {
      <b>return</b> '&lt;param name="'+name+'" value="'+value+'" /&gt;';
    }

<span class="singleComment">    // safety check for legacy (change to Flash 9 URL)</span>
    _setVersionInfo();
    _s.url = _normalizeMovieURL(_overHTTP?remoteURL:localURL);
    smURL = _s.url;

    _s.wmode = (!_s.wmode && _s.useHighPerformance ? 'transparent' : _s.wmode);

    <b>if </b>(_s.wmode !== <b>null</b> && (_ua.match(/msie 8/i) || (!_isIE && !_s.useHighPerformance)) && navigator.platform.match(/win32|win64/i)) {
<span class="multiComment">      /**
       * extra-special case: movie doesn't load until scrolled into view when using wmode = anything but 'window' here
       * does not apply when using high performance (position:fixed means on-screen), OR infinite flash load timeout
       * wmode breaks IE 8 on Vista + Win7 too in some cases, as of January 2011 (?)
       */</span>
      _wDS('spcWmode');
      _s.wmode = <b>null</b>;
    }

    oEmbed = {
      'name': smID,
      'id': smID,
      'src': smURL,
      'quality': 'high',
      'allowScriptAccess': _s.allowScriptAccess,
      'bgcolor': _s.bgColor,
      'pluginspage': _http+'www.macromedia.com/go/getflashplayer',
      'title': swfTitle,
      'type': 'application/x-shockwave-flash',
      'wmode': _s.wmode,
<span class="singleComment">      // http://help.adobe.com/en_US/as3/mobile/WS4bebcd66a74275c36cfb8137124318eebc6-7ffd.html</span>
      'hasPriority': '<b>true</b>'
    };

    <b>if </b>(side !== <b>null</b>) {
<span class="singleComment">      // don't specify width/height if null.</span>
      oEmbed.width = side;
      oEmbed.height = side;
    }

    <b>if </b>(_s.debugFlash) {
      oEmbed.FlashVars = 'debug=1';
    }

    <b>if </b>(!_s.wmode) {
<span class="singleComment">      // don't write empty attribute</span>
      <b>delete </b>oEmbed.wmode;
    }

    <b>if </b>(_isIE) {

<span class="singleComment">      // IE is "special".</span>
      oMovie = _doc.createElement('div');
      movieHTML = [
        '&lt;object id="' + smID + '" data="' + smURL + '" type="' + oEmbed.type + '" title="' + oEmbed.title +'" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="' + _http+'download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0" width="' + oEmbed.width + '" height="' + oEmbed.height + '"&gt;',
        param('movie', smURL),
        param('AllowScriptAccess', _s.allowScriptAccess),
        param('quality', oEmbed.quality),
        (_s.wmode? param('wmode', _s.wmode): ''),
        param('bgcolor', _s.bgColor),
        param('hasPriority', '<b>true</b>'),
        (_s.debugFlash ? param('FlashVars', oEmbed.FlashVars) : ''),
        '&lt;/object&gt;'
      ].join('');

    } <b>else </b>{

      oMovie = _doc.createElement('embed');
      <b>for </b>(tmp<b> in </b>oEmbed) {
        <b>if </b>(oEmbed.hasOwnProperty(tmp)) {
          oMovie.setAttribute(tmp, oEmbed[tmp]);
        }
      }

    }

    _initDebug();
    extraClass = _getSWFCSS();
    oTarget = _getDocument();

    <b>if </b>(oTarget) {

      _s.oMC = (_id(_s.movieID) || _doc.createElement('div'));

      <b>if </b>(!_s.oMC.id) {

        _s.oMC.id = _s.movieID;
        _s.oMC.className = _swfCSS.swfDefault + ' ' + extraClass;
        s = <b>null</b>;
        oEl = <b>null</b>;

        <b>if </b>(!_s.useFlashBlock) {
          <b>if </b>(_s.useHighPerformance) {
<span class="singleComment">            // on-screen at all times</span>
            s = {
              'position': 'fixed',
              'width': '8px',
              'height': '8px',
<span class="singleComment">              // &gt;= 6px for flash to run fast, &gt;= 8px to start up under Firefox/win32 in some cases. odd? yes.</span>
              'bottom': '0px',
              'left': '0px',
              'overflow': 'hidden'
            };
          } <b>else </b>{
<span class="singleComment">            // hide off-screen, lower priority</span>
            s = {
              'position': 'absolute',
              'width': '6px',
              'height': '6px',
              'top': '-9999px',
              'left': '-9999px'
            };
            <b>if </b>(isRTL) {
              s.left = Math.abs(parseInt(s.left,10))+'px';
            }
          }
        }

        <b>if </b>(_isWebkit) {
<span class="singleComment">          // soundcloud-reported render/crash fix, safari 5</span>
          _s.oMC.style.zIndex = 10000;
        }

        <b>if </b>(!_s.debugFlash) {
          <b>for </b>(x<b> in </b>s) {
            <b>if </b>(s.hasOwnProperty(x)) {
              _s.oMC.style[x] = s[x];
            }
          }
        }

        <b>try </b>{
          <b>if </b>(!_isIE) {
            _s.oMC.appendChild(oMovie);
          }
          oTarget.appendChild(_s.oMC);
          <b>if </b>(_isIE) {
            oEl = _s.oMC.appendChild(_doc.createElement('div'));
            oEl.className = _swfCSS.swfBox;
            oEl.innerHTML = movieHTML;
          }
          _appendSuccess = <b>true</b>;
        } <b>catch </b>(e) {
          <b>throw </b><b>new </b>Error(_str('domError')+' \n'+e.toString());
        }

      } <b>else </b>{

<span class="singleComment">        // SM2 container is already in the document (eg. flashblock use case)</span>
        sClass = _s.oMC.className;
        _s.oMC.className = (sClass?sClass+' ':_swfCSS.swfDefault) + (extraClass?' '+extraClass:'');
        _s.oMC.appendChild(oMovie);
        <b>if </b>(_isIE) {
          oEl = _s.oMC.appendChild(_doc.createElement('div'));
          oEl.className = _swfCSS.swfBox;
          oEl.innerHTML = movieHTML;
        }
        _appendSuccess = <b>true</b>;

      }

    }

    _didAppend = <b>true</b>;
    _initMsg();
    _s._wD(_smc+'createMovie(): Trying to load ' + smURL + (!_overHTTP && _s.altURL?' (alternate URL)':''), 1);

    <b>return</b> <b>true</b>;

  };

  _initMovie = <b>function </b>() {

    <b>if </b>(_s.html5Only) {
      _createMovie();
      <b>return</b> <b>false</b>;
    }

<span class="singleComment">    // attempt to get, or create, movie</span>
<span class="singleComment">    // may already exist</span>
    <b>if </b>(_flash) {
      <b>return</b> <b>false</b>;
    }

<span class="singleComment">    // inline markup case</span>
    _flash = _s.getMovie(_s.id);

    <b>if </b>(!_flash) {
      <b>if </b>(!_oRemoved) {
<span class="singleComment">        // try to create</span>
        _createMovie(_s.id, _s.url);
      } <b>else </b>{
<span class="singleComment">        // try to re-append removed movie after reboot()</span>
        <b>if </b>(!_isIE) {
          _s.oMC.appendChild(_oRemoved);
        } <b>else </b>{
          _s.oMC.innerHTML = _oRemovedHTML;
        }
        _oRemoved = <b>null</b>;
        _didAppend = <b>true</b>;
      }
      _flash = _s.getMovie(_s.id);
    }

<span class="singleComment">    // &lt;d&gt;</span>
    <b>if </b>(_flash) {
      _wDS('waitEI');
    }
<span class="singleComment">    // &lt;/d&gt;</span>

    <b>if </b>(_s.oninitmovie<b> instanceof </b>Function) {
      setTimeout(_s.oninitmovie, 1);
    }

    <b>return</b> <b>true</b>;

  };

  _delayWaitForEI = <b>function </b>() {

    setTimeout(_waitForEI, 1000);

  };

  _waitForEI = <b>function </b>() {

    <b>if </b>(_waitingForEI) {
      <b>return</b> <b>false</b>;
    }

    _waitingForEI = <b>true</b>;
    _event.remove(_win, 'load', _delayWaitForEI);

    <b>if </b>(_tryInitOnFocus && !_isFocused) {
<span class="singleComment">      // giant Safari 3.1 hack - assume mousemove = focus given lack of focus event</span>
      _wDS('waitFocus');
      <b>return</b> <b>false</b>;
    }

    <b>var </b>p;
    <b>if </b>(!_didInit) {
      p = _s.getMoviePercent();
      _s._wD(_str('waitImpatient', (p === 100?' (SWF loaded)':(p &gt; 0?' (SWF ' + p + '% loaded)':''))));
    }

    setTimeout(<b>function </b>() {

      p = _s.getMoviePercent();

<span class="singleComment">      // &lt;d&gt;</span>
      <b>if </b>(!_didInit) {
        _s._wD(_sm + ': No Flash response within expected time.\nLikely causes: ' + (p === 0?'Loading ' + _s.movieURL + ' may have failed (and/or Flash ' + _fV + '+ not present?), ':'') + 'Flash blocked or JS-Flash security error.' + (_s.debugFlash?' ' + _str('checkSWF'):''), 2);
        <b>if </b>(!_overHTTP && p) {
          _wDS('localFail', 2);
          <b>if </b>(!_s.debugFlash) {
            _wDS('tryDebug', 2);
          }
        }
        <b>if </b>(p === 0) {
<span class="singleComment">          // if 0 (not null), probably a 404.</span>
          _s._wD(_str('swf404', _s.url));
        }
        _debugTS('flashtojs', <b>false</b>, ': Timed out' + _overHTTP?' (Check flash security or flash blockers)':' (No plugin/missing SWF?)');
      }
<span class="singleComment">      // &lt;/d&gt;</span>

<span class="singleComment">      // give up / time-out, depending</span>

      <b>if </b>(!_didInit && _okToDisable) {
        <b>if </b>(p === <b>null</b>) {
<span class="singleComment">          // SWF failed. Maybe blocked.</span>
          <b>if </b>(_s.useFlashBlock || _s.flashLoadTimeout === 0) {
            <b>if </b>(_s.useFlashBlock) {
              _flashBlockHandler();
            }
            _wDS('waitForever');
          } <b>else </b>{
<span class="singleComment">            // old SM2 behaviour, simply fail</span>
            _failSafely(<b>true</b>);
          }
        } <b>else </b>{
<span class="singleComment">          // flash loaded? Shouldn't be a blocking issue, then.</span>
          <b>if </b>(_s.flashLoadTimeout === 0) {
             _wDS('waitForever');
          } <b>else </b>{
            _failSafely(<b>true</b>);
          }
        }
      }

    }, _s.flashLoadTimeout);

  };

  _handleFocus = <b>function </b>() {

    function cleanup() {
      _event.remove(_win, 'focus', _handleFocus);
      _event.remove(_win, 'load', _handleFocus);
    }

    <b>if </b>(_isFocused || !_tryInitOnFocus) {
      cleanup();
      <b>return</b> <b>true</b>;
    }

    _okToDisable = <b>true</b>;
    _isFocused = <b>true</b>;
    _s._wD(_smc+'handleFocus()');

    <b>if </b>(_isSafari && _tryInitOnFocus) {
      _event.remove(_win, 'mousemove', _handleFocus);
    }

<span class="singleComment">    // allow init to restart</span>
    _waitingForEI = <b>false</b>;

    cleanup();
    <b>return</b> <b>true</b>;

  };

  _showSupport = <b>function </b>() {

    <b>var </b>item, tests = [];

    <b>if </b>(_s.useHTML5Audio && _s.hasHTML5) {
      <b>for </b>(item<b> in </b>_s.audioFormats) {
        <b>if </b>(_s.audioFormats.hasOwnProperty(item)) {
          tests.push(item + ': ' + _s.html5[item] + (!_s.html5[item] && _hasFlash && _s.flash[item] ? ' (using flash)' : (_s.preferFlash && _s.flash[item] && _hasFlash ? ' (preferring flash)': (!_s.html5[item] ? ' (' + (_s.audioFormats[item].required ? 'required, ':'') + 'and no flash support)' : ''))));
        }
      }
      _s._wD('-- SoundManager 2: HTML5 support tests ('+_s.html5Test+'): '+tests.join(', ')+' --',1);
    }

  };

  _initComplete = <b>function </b>(bNoDisable) {

    <b>if </b>(_didInit) {
      <b>return</b> <b>false</b>;
    }

    <b>if </b>(_s.html5Only) {
<span class="singleComment">      // all good.</span>
      _s._wD('-- SoundManager 2: loaded --');
      _didInit = <b>true</b>;
      _initUserOnload();
      _debugTS('onload', <b>true</b>);
      <b>return</b> <b>true</b>;
    }

    <b>var </b>wasTimeout = (_s.useFlashBlock && _s.flashLoadTimeout && !_s.getMoviePercent()),
        error;

    <b>if </b>(!wasTimeout) {
      _didInit = <b>true</b>;
      <b>if </b>(_disabled) {
        error = {type: (!_hasFlash && _needsFlash ? 'NO_FLASH' : 'INIT_TIMEOUT')};
      }
    }

    _s._wD('-- SoundManager 2 ' + (_disabled?'failed to load':'loaded') + ' (' + (_disabled?'security/load error':'OK') + ') --', 1);

    <b>if </b>(_disabled || bNoDisable) {
      <b>if </b>(_s.useFlashBlock && _s.oMC) {
        _s.oMC.className = _getSWFCSS() + ' ' + (_s.getMoviePercent() === <b>null</b>?_swfCSS.swfTimedout:_swfCSS.swfError);
      }
      _processOnEvents({type:'ontimeout', error:error});
      _debugTS('onload', <b>false</b>);
      _catchError(error);
      <b>return</b> <b>false</b>;
    } <b>else </b>{
      _debugTS('onload', <b>true</b>);
    }

    <b>if </b>(_s.waitForWindowLoad && !_windowLoaded) {
      _wDS('waitOnload');
      _event.add(_win, 'load', _initUserOnload);
      <b>return</b> <b>false</b>;
    } <b>else </b>{
<span class="singleComment">      // &lt;d&gt;</span>
      <b>if </b>(_s.waitForWindowLoad && _windowLoaded) {
        _wDS('docLoaded');
      }
<span class="singleComment">      // &lt;/d&gt;</span>
      _initUserOnload();
    }

    <b>return</b> <b>true</b>;

  };

  _init = <b>function </b>() {

    _wDS('init');

<span class="singleComment">    // called after onload()</span>

    <b>if </b>(_didInit) {
      _wDS('didInit');
      <b>return</b> <b>false</b>;
    }

    function _cleanup() {
      _event.remove(_win, 'load', _s.beginDelayedInit);
    }

    <b>if </b>(_s.html5Only) {
      <b>if </b>(!_didInit) {
<span class="singleComment">        // we don't need no steenking flash!</span>
        _cleanup();
        _s.enabled = <b>true</b>;
        _initComplete();
      }
      <b>return</b> <b>true</b>;
    }

<span class="singleComment">    // flash path</span>
    _initMovie();

    <b>try </b>{

      _wDS('flashJS');

<span class="singleComment">      // attempt to talk to Flash</span>
      _flash._externalInterfaceTest(<b>false</b>);

<span class="singleComment">      // apply user-specified polling interval, OR, if "high performance" set, faster vs. default polling</span>
<span class="singleComment">      // (determines frequency of whileloading/whileplaying callbacks, effectively driving UI framerates)</span>
      _setPolling(<b>true</b>, (_s.flashPollingInterval || (_s.useHighPerformance ? 10 : 50)));

      <b>if </b>(!_s.debugMode) {
<span class="singleComment">        // stop the SWF from making debug output calls to JS</span>
        _flash._disableDebug();
      }

      _s.enabled = <b>true</b>;
      _debugTS('jstoflash', <b>true</b>);

      <b>if </b>(!_s.html5Only) {
<span class="singleComment">        // prevent browser from showing cached page state (or rather, restoring "suspended" page state) via back button, because flash may be dead</span>
<span class="singleComment">        // http://www.webkit.org/blog/516/webkit-page-cache-ii-the-unload-event/</span>
        _event.add(_win, 'unload', _doNothing);
      }

    } <b>catch </b>(e) {

      _s._wD('js/flash exception: ' + e.toString());
      _debugTS('jstoflash', <b>false</b>);
      _catchError({type:'JS_TO_FLASH_EXCEPTION', fatal:<b>true</b>});
<span class="singleComment">      // don't disable, for reboot()</span>
      _failSafely(<b>true</b>);
      _initComplete();

      <b>return</b> <b>false</b>;

    }

    _initComplete();

<span class="singleComment">    // disconnect events</span>
    _cleanup();

    <b>return</b> <b>true</b>;

  };

  _domContentLoaded = <b>function </b>() {

    <b>if </b>(_didDCLoaded) {
      <b>return</b> <b>false</b>;
    }

    _didDCLoaded = <b>true</b>;
    _initDebug();

<span class="multiComment">    /**
     * Temporary feature: allow force of HTML5 via URL params: sm2-usehtml5audio=0 or 1
     * Ditto for sm2-preferFlash, too.
     */</span>
<span class="singleComment">    // &lt;d&gt;</span>
    (<b>function </b>(){

      <b>var </b>a = 'sm2-usehtml5audio=', l = _wl.toLowerCase(), b = <b>null</b>,
      a2 = 'sm2-preferflash=', b2 = <b>null</b>, hasCon = (<b>typeof </b>console !== 'undefined' && <b>typeof </b>console.log !== 'undefined');

      <b>if </b>(l.indexOf(a) !== -1) {
        b = (l.charAt(l.indexOf(a)+a.length) === '1');
        <b>if </b>(hasCon) {
          console.log((b?'Enabling ':'Disabling ')+'useHTML5Audio via URL parameter');
        }
        _s.useHTML5Audio = b;
      }

      <b>if </b>(l.indexOf(a2) !== -1) {
        b2 = (l.charAt(l.indexOf(a2)+a2.length) === '1');
        <b>if </b>(hasCon) {
          console.log((b2?'Enabling ':'Disabling ')+'preferFlash via URL parameter');
        }
        _s.preferFlash = b2;
      }

    }());
<span class="singleComment">    // &lt;/d&gt;</span>

    <b>if </b>(!_hasFlash && _s.hasHTML5) {
      _s._wD('SoundManager: No Flash detected'+(!_s.useHTML5Audio?', enabling HTML5.':'. Trying HTML5-only mode.'));
      _s.useHTML5Audio = <b>true</b>;
<span class="singleComment">      // make sure we aren't preferring flash, either</span>
<span class="singleComment">      // TODO: preferFlash should not matter if flash is not installed. Currently, stuff breaks without the below tweak.</span>
      _s.preferFlash = <b>false</b>;
    }

    _testHTML5();
    _s.html5.usingFlash = _featureCheck();
    _needsFlash = _s.html5.usingFlash;
    _showSupport();

    <b>if </b>(!_hasFlash && _needsFlash) {
      _s._wD('SoundManager: Fatal error: Flash is needed to play some required formats, but is not available.');
<span class="singleComment">      // TODO: Fatal here vs. timeout approach, etc.</span>
<span class="singleComment">      // hack: fail sooner.</span>
      _s.flashLoadTimeout = 1;
    }

    <b>if </b>(_doc.removeEventListener) {
      _doc.removeEventListener('DOMContentLoaded', _domContentLoaded, <b>false</b>);
    }

    _initMovie();
    <b>return</b> <b>true</b>;

  };

  _domContentLoadedIE = <b>function </b>() {

    <b>if </b>(_doc.readyState === 'complete') {
      _domContentLoaded();
      _doc.detachEvent('onreadystatechange', _domContentLoadedIE);
    }

    <b>return</b> <b>true</b>;

  };

  _winOnLoad = <b>function </b>() {
<span class="singleComment">    // catch edge case of _initComplete() firing after window.load()</span>
    _windowLoaded = <b>true</b>;
    _event.remove(_win, 'load', _winOnLoad);
  };

<span class="singleComment">  // sniff up-front</span>
  _detectFlash();

<span class="singleComment">  // focus and window load, init (primarily flash-driven)</span>
  _event.add(_win, 'focus', _handleFocus);
  _event.add(_win, 'load', _handleFocus);
  _event.add(_win, 'load', _delayWaitForEI);
  _event.add(_win, 'load', _winOnLoad);


  <b>if </b>(_isSafari && _tryInitOnFocus) {
<span class="singleComment">    // massive Safari 3.1 focus detection hack</span>
    _event.add(_win, 'mousemove', _handleFocus);
  }

  <b>if </b>(_doc.addEventListener) {

    _doc.addEventListener('DOMContentLoaded', _domContentLoaded, <b>false</b>);

  } <b>else </b><b>if </b>(_doc.attachEvent) {

    _doc.attachEvent('onreadystatechange', _domContentLoadedIE);

  } <b>else </b>{

<span class="singleComment">    // no add/attachevent support - safe to assume no JS -&gt; Flash either</span>
    _debugTS('onload', <b>false</b>);
    _catchError({type:'NO_DOM2_EVENTS', fatal:<b>true</b>});

  }

  <b>if </b>(_doc.readyState === 'complete') {
<span class="singleComment">    // DOMReady has already happened.</span>
    setTimeout(_domContentLoaded,100);
  }

} // SoundManager()

<span class="singleComment">// SM2_DEFER details: http://www.schillmania.com/projects/soundmanager2/doc/getstarted/#lazy-loading</span>

<b>if </b>(<b>typeof </b>SM2_DEFER === 'undefined' || !SM2_DEFER) {
  soundManager = <b>new </b>SoundManager();
}

<span class="multiComment">/**
 * SoundManager public interfaces
 * ------------------------------
 */</span>

window.SoundManager = SoundManager; // constructor
window.soundManager = soundManager; // public API, flash callbacks etc.

}(window));

</pre>
<hr/>
</BODY>
</HTML>
